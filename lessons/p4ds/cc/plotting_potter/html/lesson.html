<!DOCTYPE html><html lang='en'><head><title>Plotting Potter</title><meta charset="utf-8"><style>/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}h1{font-size:2em;margin:.67em 0}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}strong{font-weight:bolder}code{font-family:monospace,monospace;font-size:1em}img{border-style:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}h1,h2,h3,p,pre{margin:0}ul{list-style:none;margin:0;padding:0}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e2e8f0}img{border-style:solid}h1,h2,h3{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}code,pre{font-family:Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}img{display:block;vertical-align:middle}img{max-width:100%;height:auto}.bg-gray-200{--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.bg-gray-300{--bg-opacity:1;background-color:#e2e8f0;background-color:rgba(226,232,240,var(--bg-opacity))}.bg-blue-200{--bg-opacity:1;background-color:#bee3f8;background-color:rgba(190,227,248,var(--bg-opacity))}.bg-blue-300{--bg-opacity:1;background-color:#90cdf4;background-color:rgba(144,205,244,var(--bg-opacity))}.border-gray-400{--border-opacity:1;border-color:#cbd5e0;border-color:rgba(203,213,224,var(--border-opacity))}.border-gray-500{--border-opacity:1;border-color:#a0aec0;border-color:rgba(160,174,192,var(--border-opacity))}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.border-solid{border-style:solid}.border{border-width:1px}.border-t{border-top-width:1px}.inline-block{display:inline-block}.flex{display:flex}.justify-center{justify-content:center}.justify-around{justify-content:space-around}.clearfix:after{content:"";display:table;clear:both}.font-serif{font-family:Georgia,Cambria,"Times New Roman",Times,serif}.font-semibold{font-weight:600}.font-bold{font-weight:700}.h-64{height:16rem}.text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-base{font-size:1rem}.text-xl{font-size:1.25rem}.leading-none{line-height:1}.m-2{margin:.5rem}.my-4{margin-top:1rem;margin-bottom:1rem}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.mr-2{margin-right:.5rem}.mb-2{margin-bottom:.5rem}.mb-3{margin-bottom:.75rem}.mt-4{margin-top:1rem}.mt-6{margin-top:1.5rem}.max-w-sm{max-width:24rem}.max-w-2xl{max-width:42rem}.object-contain{-o-object-fit:contain;object-fit:contain}.overflow-hidden{overflow:hidden}.p-1{padding:.25rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pl-3{padding-left:.75rem}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}.shadow-inner{box-shadow:inset 0 2px 4px 0 rgba(0,0,0,.06)}.text-left{text-align:left}.text-center{text-align:center}.text-black{--text-opacity:1;color:#000;color:rgba(0,0,0,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-800{--text-opacity:1;color:#2d3748;color:rgba(45,55,72,var(--text-opacity))}.whitespace-no-wrap{white-space:nowrap}.w-1\/2{width:50%}.w-full{width:100%}.text-tiny{font-size:.5rem!important}body{color:#000!important;font-size:1.25rem!important}.main-content{max-width:900px}.lesson{padding-left:15px!important;padding-right:10px!important;--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.main-content,html{font-family:Arial,Georgia,Verdana,"Times New Roman"!important}.lesson-footer-card,.lesson-overview-card{font-family:"Times New Roman"!important}.lesson-footer{margin-top:50px;margin-top:20px}.lesson ul{list-style-position:inside;list-style-type:none;margin-left:1em}.lesson ul li{padding-left:1em;padding-right:5px}.lesson ul li::before{content:"•";padding-right:5px}span{white-space:nowrap}p.new{padding-top:0;padding-bottom:.5em}p.new+p{padding-top:.5em}h1,h2,h3{font-weight:700;margin-top:.25em!important;margin-bottom:.05em!important;font-family:Georgia,Cambria,"Times New Roman",Times,serif!important}h1{font-size:2em!important;clear:both;color:#000!important}div+h1,h2{margin-top:0!important}h2{margin-top:.5em!important;font-size:1.5em!important;clear:both;color:#8b0000!important}h3{font-size:1.25em!important;clear:both;color:#006400!important}ul{margin-bottom:30px}p.new a{text-decoration:underline}.lesson a{text-decoration:underline;color:#00f}.title-text{font-size:2rem}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.5)}img.center{-o-object-position:center;object-position:center;margin-left:auto;margin-right:auto}img.border{border:1px solid #021a40;margin-top:.5rem;margin-bottom:.75rem}img.iw600{height:auto;width:auto;max-width:600px}img.iw500{height:auto;width:auto;max-width:500px}code{font-size:smaller}pre code{font-size:15px}pre code:not(.line-number){background:#f4f4f4;font-family:monospace;font-size:15px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;touch-action:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;clear:both;border:1px solid #ddd;color:#666;page-break-inside:avoid;display:block;min-width:840px;max-width:840px;overflow:scroll;line-height:1.6;margin-bottom:1.6em;padding:1em 1.5em;-moz-tab-size:2;-o-tab-size:2;tab-size:2;word-wrap:break-word;white-space:pre-wrap;border-left:3px solid #f36d33}div.code-starter>pre code{border-left:3px solid #fdff44!important;background-image:radial-gradient(rgba(0,150,0,.75),#000 120%);color:#fff;font:.9rem Inconsolata,monospace}div.code-starter>pre code::after{content:"\a$_"}</style>
<script src="https://kit.fontawesome.com/7efc4bcee2.js" crossOrigin="anonymous"></script>
<script>
    let stateCheck = setInterval(function(){
      if (document.readyState === 'complete') {
        clearInterval(stateCheck);
        let s1 = document.getElementById('start');
        // console.log('doc is ready', s1);
        if (s1) {
           s1.setAttribute('tabindex', '-1');
           s1.focus(); 
           s1.scrollIntoView({behavior: 'smooth'}); 
           setTimeout(function(){s1.blur()}, 500);
           // console.log('focus set');
        }
      }
    }, 200);
    </script>
</head><body class="lesson"><div class="main-content lesson bg-gray-200 text-black p-1 pl-3 font-serif"><div class="md-inner">
<div id="start" class="section">&nbsp;</div><h1 class="overview"></h1><div class="lesson-overview bg-gray-200 flex justify-center"><div class="text-center px-4 py-2 m-2"><div class="lesson-overview-card displaycard bg-blue-200 max-w-sm rounded overflow-hidden shadow-lg"><div> </div><img alt="Text" class="object-contain h-64 w-full" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/cc-sm.png"/><div class="px-6 py-4"><div class="title-text text-center leading-none font-bold text-xl">Plotting Potter</div><p class="text-center mt-2 text-gray-800 text-xl">Harry Potter and the Plotting of Characters</p><div class="text-gray-700 text-base"> </div><div class="text-center mb-3"><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#info490</span><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#python</span></div><div class="flex border-t border-solid border-gray-500 shadow-inner justify-around bg-blue-300"><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap">🐍  4 D.S.</span></div><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap"><strong>Version:</strong> <!-- -->SP21</span></div></div><div class="text-gray-700 mt-1 text-center text-tiny">All Rights Reserved</div></div></div></div><div class="text-center px-4 py-2 m-2 w-1/2"><div class="displaycard bg-gray-200 max-w-sm rounded overflow-hidden shadow-lg"><div class="px-6 py-4 text-left"><div class="text-center font-bold text-xl">Plotting Potter<br/><div><span>prerequisites</span><div class="text-center text-xs mb-2">(start only after finishing)</div><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>Finding Characters</strong></p><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>Named Parameters</strong></p><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>NLP</strong></p><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>NumPy</strong></p><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>Matplotlib</strong></p></div></div></div><div class="px-6 py-4 text-left text-gray-800"><div class="text-center font-bold text-xl">Colab Notes</div><p class="max-w-sm text-sm">1. <strong>Copy</strong> this notebook <img alt="copy2drive.png" class="inline-block" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/copy2drive.png"/></p><p class="max-w-sm text-sm">2. <strong>Update</strong> the <strong><code>NET_ID</code></strong> in the notebook</p><p class="max-w-sm text-gray-800 text-sm">3. <strong>Hit ▶️ </strong> to install the INFO 490 IDE</p><div class="text-center font-bold text-xl"> </div><div class="text-center font-bold text-xl">Jupyter/PyCharm Notes</div><p class="max-w-sm text-gray-800 text-sm text-left">The testing framework does <strong>not work</strong> (at this time) for Jupyter  notebooks or local code development.</p></div></div></div></div><h1 class="section" id="section1">🐍 Coding Challenges: Plotting Potter</h1><h2 id="harry-potter-and-the-plotting-of-characters">Harry Potter and the Plotting of Characters</h2><img alt="ds1.png" class="center iw600" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/ds1.png"/><p class="new">Although this lesson has a bit of reading, the actual amount of new code that needs 
to be written is small.</p><h1 class="section" id="section2">Finding Potter Characters</h1><p class="new">In the Finding Characters Challenge, you wrote three functions that found 
characters in Huckleberry Finn. If you look closely at your solution, you will 
notice that the algorithm for finding the characters is NOT specific to that book. 
Other than cleaning of the text, your code should work for another book/novel.</p><p class="new">Using the power of Python we can RUN your colab notebook for that lesson
 inside this notebook!  </p><p class="new">Here's how it will work:</p><ul><li>Get the ID portion of the shareable URL of your notebook for the Finding Characters 
Lesson (be SURE that the notebook is still readable/viewable by others).</li></ul><img alt="share.png" class="border center iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/share.png"/><ul><li>Run the following code, which will treat that notebook as a Python module</li></ul><div class="ide code-starter clearfix"><pre><code>def optional_fun(nb_id, text):
    import LessonUtil as Util
    if Util.mount_notebook(nb_id):
        import lesson as notebook

        stop = Util.load_stop_words()
        c1 = notebook.find_characters_v1(text, stop, 5)
        print("v1", c1, "\n")

        c2 = notebook.find_characters_v2(text, stop, 5)
        print("v2", c2, "\n")

        c3 = notebook.find_characters_v3(text, stop, 5)
        print("v3", c3, "\n")
    else:
        print("could not mount remote notebook")


import LessonUtil as Util

# this is the document ID or url of your Finding Characters Lesson
GOOGLE_URL = 'CHANGE_ME' 

# the text of Harry Potter (book 1)
text = Util.read_data_file('harryPotter.txt')

# use your code to process the Harry Potter Text
optional_fun(GOOGLE_URL, text)</code></pre></div><p class="new">If all goes well, you will see the output of YOUR code being run with the 
text of Harry Potter and the Sorcerer's Stone.  </p><h3 id="findcharactersv1">find_characters_v1</h3><pre><code>[('Harry', 1217), ('Ron', 410), ('Hagrid', 336), 
('Hermione', 257), ('Professor', 180), ('Snape', 145), ('Dumbledore', 140), ('Dudley', 115), ("Harry's", 113), ('Uncle', 111), ('Malfoy', 109), ('Vernon', 105), ('Neville', 102), ('Potter', 97), ('McGonagall', 95)]</code></pre><h3 id="findcharactersv2">find_characters_v2</h3><pre><code>[(('Uncle', 'Vernon'), 97), (('Professor', 'McGonagall'), 90), 
(('Aunt', 'Petunia'), 51), (('Mr', 'Dursley'), 29), (('Harry', 'Potter'), 28), (('Professor', 'Dumbledore'), 20), (('Mrs', 'Dursley'), 17), (('Mr', 'Potter'), 17), (('Professor', 'Quirrell'), 17), (('Privet', 'Drive'), 16), (('Mr', 'Ollivander'), 16), (('Hermione', 'Granger'), 16), (('Nimbus', 'Two'), 15), (('Great', 'Hall'), 15), (('Professor', 'Flitwick'), 15)]</code></pre><h3 id="findcharactersv3">find_characters_v3</h3><pre><code>[(('Mr', 'Dursley'), 29), (('Mrs', 'Dursley'), 17), (('Mr', 'Potter'), 17), (('Mr', 'Ollivander'), 16), (('Mrs', 'Norris'), 12), (('Mrs', 'Figg'), 5), (('Mrs', 'Weasley'), 4), (('Mrs', "Figg's"), 3), (('Mr', 'Filch'), 3), (('Mrs', "Dursley's"), 2), (('Tap', 'Tap'), 2), (('Mr', 'Harry'), 2), (('Mr', 'Ronald'), 2), (('Mrs', 'Potter'), 1), (('Mrs', 'Next'), 1)]</code></pre><p class="new">If your code doesn't work, you will need to go back to your notebook and do some debugging.</p><p class="new">A few notes:</p><ul><li>The analysis is done on the raw text -- we would get more accurate results if 
we cleaned the text.</li><li>For <code>find_characters_v1</code> you should note that both the possessive noun and 
the regular noun are counted as separate characters. How could you fix this? 
(e.g. Harry has 1217 occurrences, and Harry's has 113 count). As an experiment, 
determine what needs to be done to find Voldemort?</li><li>This is the power of writing software that is generic -- you can reuse it!</li></ul><h2 id="nlp">NLP</h2><p class="new">You could also do the same for your NLP lesson (<code>find_characters_nlp</code>).  If you 
use the Harry Potter text for that function, your output should be:</p><h3 id="findcharactersnlp">find_characters_nlp</h3><pre><code>[('Harry', 1247), ('Ron', 409), ('Hagrid', 255), ('Hermione', 228), ('Snape', 129), ('Dudley', 114), ('Neville', 80), ('Uncle Vernon', 76), ('Dumbledore', 61), ('Quirrell', 49), ('Wood', 46), ('Malfoy', 45), ('Filch', 42), ('Professor McGonagall', 41), ('Aunt Petunia', 40), ('Potter', 36), ('Percy', 32), ('Dursley', 30), ('Uncle', 27), ('Vernon', 27), ('Slytherin', 26), ('Voldemort', 24), ('Harry Potter', 23), ('Goyle', 23), ('Mr.', 22)]</code></pre><h2 id="potter-characters">Potter Characters</h2><p class="new">Based on the above analysis, you should agree that the main characters of Harry Potter include:</p><ul><li>Harry</li><li>Ron</li><li>Hagrid</li><li>Hermione</li></ul><h3 id="missing-you-know-who">Missing You-Know-Who</h3><p class="new">Without actually reading the novel, that's what our algorithm tells us. Note that we 
would probably miss Voldemort even though that character is important to the novel (we 
might miss that question on our 9th grade english test if we relied on our code 
to "read" the book for us). Can you think of any analysis that might bring Voldemort 
to the forefront?  Make a post on Piazza of any ideas you have (try to keep all 
ideas on a single threaded post). This is a conversation starter not a requirement.</p><h1 class="section" id="section3">Lesson Assignment: Plotting Potter</h1><p class="new">For this lesson you will build a visualization like the one below.  It shows the main characters of The Adventures of Huckleberry Finn and the cumulative count of their occurrences throughout the novel.
<img alt="ds2.png" class="center iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/ds2.png"/></p><p class="new">We will build a similar graph for Harry Potter and the Sorcerer's Stone.</p><h2 id="cleaning-potter-">Cleaning Potter </h2><p class="new">Write a function named <code>clean_hp</code> that does the following to its incoming 
string parameter:</p><ul><li>remove all header information up until the title of the book</li><li>you can keep 'THE END' as well as all the page numbers</li><li>return the cleaned text</li></ul><pre><code>hp = clean_hp(text)</code></pre><p class="new">Use your knowledge of Python array slicing to take different peeks into the
 text.</p><p class="new">As a hint and good programming tip, don't use text found in the preamble -- that 
stuff can change (and does). Use the title of the book -- that's future proof and safe.</p><div class="ide code-starter clearfix"><pre><code>import LessonUtil as Util

def clean_hp(text):
   return text

text = Util.read_data_file('harryPotter.txt')
hp = clean_hp(text)</code></pre></div><h2 id="data-by-chapter">Data By Chapter</h2><p class="new">Looking at the graph that we need to build for this lesson, it's clear that we 
are going to need to get occurrence counts for the four characters for each chapter. 
Ideally, our data will look like the following (numbers are made up):</p><pre><code>harry_by_chapter   = [20, 79, 68, ...] # 17 numbers
ron_by_chapter     = [ 0, 73, 14, ...] # 17 numbers
hagrid_by_chapters = [14,  0,  0, ...] # 17 numbers</code></pre><p class="new">Note that each chapter is a column of data. We can get to this dataset with 
only a few more functions.</p><p class="new">Write a function named <code>split_into_chapters</code> that uses a regular expression to 
split the parameter text into an array of chapters</p><ul><li>return an array whose elements are the text for each chapter</li><li>each element is trimmed of leading and trailing whitespace</li><li>each element can start with the title of the chapter or the first word of
the chapter (ideally it would be the latter, but the regex is a bit more complicated)</li></ul><div class="ide code-starter clearfix"><pre><code>import re
def split_into_chapters(text):
    return []</code></pre></div><h3 id="testing">Testing</h3><p class="new">Take a look at the text of Harry Potter and the Sorcerer's Stone. You can
 either print parts of it, or <a href="https://raw.githubusercontent.com/NSF-EC/INFO490Assets/master/src/datasets/books/hp/harryPotter.txt" target="_blank">read</a> 
in another browser window.</p><p class="new">Luckily the chapters are well marked -- can you see the pattern?</p><p class="new">When you are done, the following should work (you should implement this):</p><pre><code>def test_pipeline():
    import LessonUtil as Util
    text = Util.read_data_file('harryPotter.txt')
    hp   = clean_hp(text)
    chp  = split_into_chapters(hp)

    print(len(chp))     # 17
    print(chp[0][0:18]) # THE BOY WHO LIVED
    print(chp[1][0:18]) # THE VANISHING GLAS</code></pre><p class="new">Note: 
If you had to split a novel that had to use the title of the chapters (i.e. there 
is no one pattern that can uniquely captures each of the chapters), you would 
need to do something like the following (example shows only the first 2 chapters):</p><pre><code>def split_into_chapters(text):
    # this is not the way you should solve this
    # text is huckfinn
    m1 = re.search(r"^YOU don't know about me", text, re.M)
    m2 = re.search(r"^WE went tiptoeing along", text, re.M)
    m3 = re.search(r"^WELL, I got a good going",text, re.M)
    chp1 = text[m1.span()[0]: m2.span()[0]]
    chp2 = text[m2.span()[0]: m3.span()[0]]
    return [chp1, chp2]</code></pre><p class="new">The ^ and $ insist you are uniquely capturing the correct text. Clearly this is 
a last resort solution.</p><div class="ide code-starter clearfix"><pre><code></code></pre></div><h2 id="character-counts--">Character Counts.  </h2><p class="new">You are now ready to use Numpy to easily get the counts for the four main 
characters for each chapter.  </p><p class="new">Create an array that has a count for the total number of occurrences the name 
appeared in each chapter. Finish this implementation.</p><p class="new">The Numpy lesson has the function to get the counts from a string (and an example). 
As mentioned previously, after you are done your arrays should look like 
this (but not Python lists) (and the numbers are fictitious).</p><pre><code>harry_by_chapter  = [20, 79, 68, ...] # 17 numbers
ron_by_chapter    = [ 0, 73, 14, ...] # 17 numbers
hagrid_by_chapter = [14,  0,  0, ...] # 17 numbers</code></pre><div class="ide code-starter clearfix"><pre><code>def get_character_counts_v1(chapters):

  harry    = ...
  ron      = ...
  hagrid   = ...
  hermione = ...

  return np.array([harry, ron, hagrid, hermione])</code></pre></div><p class="new">Note:</p><p class="new">If a character is referenced using multiple names or nicknames (something our 
analysis has not done), you could combine them:</p><pre><code>harry  =       [20, 79, 68]
potter =       [21,  2, 4]
harry_potter = [5,   2, 0]

hp_counts = harry + potter - harry_potter
# [36, 79, 72]</code></pre><p class="new">This adds all 'Harry' and 'Potter' references together but adjusts for the 
double counting when the full reference to "Harry Potter" is made. Think of 
properly counting characters in the following sentences: </p><p class="new">"Harry?" "Is that you Potter? "I'm not kidding Harry Potter, I need to see you NOW". </p><p class="new">There are 3 references to the same character (not counting pronouns). Do <strong>not</strong> 
do this, but it is something to keep in mind.  </p><h2 id="plotting-characters">Plotting Characters</h2><p class="new">Using the same set up as in the Matplotlib lesson, plot each character:</p><pre><code>def simple_graph_v1(plots):

  fig = plt.figure()
  subplot = fig.add_subplot(1,1,1)

  subplot.plot(plots[0])
  subplot.plot(plots[1])
  subplot.plot(plots[2])
  subplot.plot(plots[3]) 

  # this is important for testing
  return fig</code></pre><p class="new">Note that we are now calling the plot method on the returned subplot (a.k.a axes 
object) from the <code>add_subplot</code> method. In a previous lesson we 
called <code>subplot.bar(x_pos, counts)</code> to generate a bar graph. The plot method 
generates a line graph.  </p><p class="new">Once that is done the following should work (be sure to test this):</p><div class="ide code-starter clearfix"><pre><code>import matplotlib.pyplot as plt
import re
import numpy as np

def simple_graph_v1(plots):
   return None

def pipeline_v1():

  import LessonUtil as Util
  text = Util.read_data_file('harryPotter.txt')
  hp   = clean_hp(text)
  chapters = split_into_chapters(hp)

  plots = get_character_counts_v1(chapters)
  fig = simple_graph_v1(plots)
  return fig</code></pre></div><p class="new">You should see something like the following:
<img alt="ds3.png" class="border center iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/ds3.png"/></p><p class="new">This doesn't really look like the graph for which we are aiming. But it's a good 
start. We can see the counts for the four main characters of the novel and we 
found the characters without reading a single word!! (maybe we shouldn't celebrate this?)</p><h1 class="section" id="section4">Pass Two</h1><h2 id="better-data-pipeline">Better Data Pipeline</h2><p class="new">The issue with the code to build the plot above (it has several), is that if we 
wanted to analyze <em>five</em> characters, we would have to add a new variable, another 
parameter to the function, and update the code as well. This is a symptom of a 
poor design -- "code smell".  It would be better to allow the user of your
 code to pass in the characters s/he wanted to plot.  </p><p class="new">Write a function named <code>get_character_counts_v2</code> whose parameter, <code>names</code>, is a 
list of characters (as strings) for which data will be prepared. It returns 
a single Numpy array that represents the character counts for each chapter. This 
function will perform the same as <code>get_character_counts_v1</code>.</p><div class="ide code-starter clearfix"><pre><code>def get_character_counts_v2(chapters, names):

  # use the same function as v1
  # use a comprehension to easily get things done:
  py_data = [ &lt;CODE GOES HERE&gt; for n in names ]
  counts = np.array(py_data)

  return counts</code></pre></div><p class="new">You can now test it:</p><pre><code>def test_v2():
    import LessonUtil as Util
    text = Util.read_data_file('harryPotter.txt')
    hp   = clean_hp(text)
    who = ["Ron", "Hagrid"] 
    chapters = split_into_chapters(hp)
    data = get_character_counts_v2(chapters, who)
    print(data)
    print(data.shape)</code></pre><p class="new">Look at the shape of the <code>np.array</code> that is returned by the function. Make sure 
you understand it. Also note how the data is different from the <code>v1</code> version.</p><p class="new">Now implement the following function that puts all the parts together in a coherent data pipeline:</p><pre><code>def pipeline_v2(names):

    import LessonUtil as Util
    text = Util.read_data_file('harryPotter.txt')
    hp   = clean_hp(text)
    chapters = split_into_chapters(hp)
 
    return get_character_counts_v2(chapters, names)</code></pre><p class="new">And test it:</p><pre><code>who = ["Harry", "Ron", "Hagrid", "Hermione"]
print(pipeline_v2(who))</code></pre><h2 id="better-data-better-plotting">Better Data, Better Plotting?</h2><p class="new">Let's update the matplotlib plot function to handle a single array:</p><div class="ide code-starter clearfix"><pre><code>def simple_graph_v2(counts):
  fig = plt.figure()
  subplot = fig.add_subplot(1,1,1)
  subplot.plot(counts)
  return fig  # return the figure</code></pre></div><p class="new">And of course, test it:</p><pre><code>who = ["Harry", "Ron", "Hagrid", "Hermione"]
data = pipeline_v2(who)
fig = simple_graph_v2(data)</code></pre><p class="new">You will get something like the following diagram:</p><img alt="ds4.png" class="border center iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/ds4.png"/><p class="new">Clearly something is <strong>wrong</strong>.  </p><p class="new">The lines being drawn are the chapters. The issue is that if you pass this 
single 2D array to plot, you will need to get the data into the proper shape. 
Looking at the <a href="https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot" target="_blank">matplotlib documentation</a> 
(which we all should be doing), it says the following: </p><pre><code> .. The parameters can also be 2-dimensional. Then, the columns represent separate data sets.</code></pre><p class="new">So matplotlib is looking at the <em>columns</em>. Where each column needs to represent 
the same entity -- or character in our case.</p><p class="new">We need to transform our data.  Right now the columns represent chapters.</p><pre><code>harry_by_chapter   = [20, 79, 68, ...] # 17 numbers
ron_by_chapter     = [ 0, 73, 14, ...] # 17 numbers
hagrid_by_chapters = [14,  0,  0, ...] # 17 numbers</code></pre><p class="new">We need each column to be the data for each character:</p><pre><code>[
   #HP  #Ron  #Hagrid
   [20,   0,  14]
   [79,  73,   0]
   [68,  14,   0]
    ...
]</code></pre><p class="new">This requires data wrangling!</p><p class="new">Update <code>get_character_counts_v2</code> to use <code>np.transpose</code> the data (see Numpy lesson) 
to get the array into the correct format. Be sure to print out the results and 
make sure you understand the data.  </p><pre><code>def get_character_counts_v2(chapters, names):

  counts = ... 
  # transpose data here

  return counts</code></pre><p class="new">You can now pass the transformed data into <code>simple_graph_v2</code> and see the first 
graph you created using the individual characters (which is where we started, 
but now we have a more flexible pipeline and you're using Numpy a close friend 
of Matplotlib):</p><img alt="ds5.png" class="border center iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/ds5.png"/><h2 id="smoothing-out-the-rough-edges">Smoothing out the rough edges</h2><p class="new">Although this graph does present good information, it is a bit harsh to look at. 
Instead of plotting the raw counts across the chapters, plot the <em>cumulative</em> sum 
for each of the characters. You can use the Numpy's <code>np.cumsum</code> method. It 
basically creates an array whose elements represent a running sum of the input:</p><div class="ide code-starter clearfix"><pre><code>import numpy as np
values = [1, 0, 2, 0, 3]
print(np.cumsum(values))</code></pre></div><p class="new">You should see: <code>[1 1 3 3 6]</code>. Does that make sense?</p><p class="new">Update the <code>get_character_counts</code> function to get the cumulative sums for each array:</p><pre><code>def get_character_counts_v2(chapters, names):

  counts = ...
  # counts = np.cumsum( ... )
  # now transform counts

  return counts</code></pre><p class="new">Note that you can do this either before or after the data transposition, 
but you will need to play with the axis parameter (since our data is two 
dimensional). Your final data should have columns of monotonically increasing 
values (always increasing or remaining constant, and never decreasing). 
A simple example is given below (for 3 characters):</p><pre><code>[
  [ 37   9   6]  ⌾
  [ 37  63   6]  | monotonically
  [ 37 113   6]  |  increasing
  [ 46 125   7]  |    values
  [ 51 129   7]  ˅
    ...
]</code></pre><p class="new">Your data must still have the shape of (# of chapters, # of characters).<br/>Your final graph (still very simple) should have the smooth look similar to 
the one that started off the lesson. </p><p class="new">Your updated pipeline should now look like this (we moved creating the 
figure into the v2 pipeline (which is returned as well):</p><pre><code>def pipeline_v3(names):

    import LessonUtil as Util
    text = Util.read_data_file('harryPotter.txt')
    hp   = clean_hp(text)
    chapters = split_into_chapters(hp)

    np_hp = get_character_counts_v2(chapters, names)
    fig   = simple_graph_v2(np_hp)
    return fig

who = ["Harry", "Ron", "Hagrid", "Hermione"]
fig = pipeline_v3(who)</code></pre><div class="ide code-starter clearfix"><pre><code></code></pre></div><img alt="ds6.png" class="border center iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/ds6.png"/><p class="new">That looks much better. All is left is to add some embellishments and fix a 
few details (see extra credit)</p><h2 id="insights">Insights?</h2><p class="new">Can you find a few interesting facts about the characters in Harry Potter and 
the Sorcerer's Stone using only the visualization? </p><h2 id="be-proud">Be Proud</h2><p class="new">You should feel pretty good about your programming chops. You proved that you can 
use NLP or your own algorithms to flush out characters and plot their occurrences 
throughout a novel. You can also play with different characters as well -- your 
code should adapt to any number of characters you want to graph. That is powerful.</p><h1 class="section" id="section5">Extra Credit</h1><h2 id="gussy-it-up">Gussy it Up</h2><img alt="ds7.png" class="border center iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/cc/plotting_potter/html/ds7.png"/><p class="new">Although the graph you created has the most important part -- accurate data, 
it will be helpful to label and color the characters.</p><p class="new">Define a function named <code>simple_graph_hp(counts, names)</code> which adds all the 
necessary embellishments to make your graph look like the one above: </p><ul><li>set the figure's title to 'HP Characters &lt;your initials here&gt;' with your initials as well (without the &lt;&gt;)</li><li>add a grid background</li><li>set the x and y axis labels</li><li>set the x axis tick markers to be for each chapter (e.g. 1 through 17) but do 
NOT hard-code the number 17 (get it from the data)</li><li>add a legend for each of the characters (you can pick the location)</li><li>style your graph using either fivethirtyeight or seaborn</li><li>make sure the labels don't get cut off</li></ul><p class="new">Create the following as well: (only if doing extra credit)</p><pre><code>def pipeline_hp(names):
    calls simple_graph_hp
    return the figure created from the pipeline

who = ["Harry", "Ron", "Hagrid", "Hermione"] 
fig = pipeline_hp(who)</code></pre><h1>Test and Submit</h1><p>Once you have finished, you can download your code (via <code>ide.tester</code>) and upload that file to Gradescope (find lesson with tag <strong>CC-PlottingPotter</strong>).</p><div class="my-4"><pre><code><strong># to list the tests available</strong><br/>print(ide.tester.list_tests())<br/><strong># to perform a specific test</strong><br/>print(ide.tester.test_functionality('name of test'))<br/><strong># to test your code (either works)</strong><br/>print(ide.tester.test_notebook())<br/>print(ide.tester.test_notebook(verbose=True))<br/><strong># to prepare and download your code</strong><br/>ide.tester.download_solution()</code></pre></div><div class="lesson-footer flex bg-gray-200 justify-center"><div class="lesson-footer-card displaycard bg-blue-200 border-t border-gray-400 max-w-2xl rounded overflow-hidden shadow-lg"><div class="px-6 py-4"><div class="title-text text-center font-bold text-xl">Plotting Potter</div><p class="text-center text-gray-800 text-xl">Harry Potter and the Plotting of Characters</p><div class="text-center mt-6 text-xl"><i aria-hidden="true" class="fas fa-tags"></i> any questions on Piazza with <span class="font-bold">CC-PlottingPotter</span></div><div class="text-gray-700 text-base"> </div><div></div><div></div><div class="flex mt-4 border-t border-solid border-gray-500 justify-around bg-gray-200"><div class="text-gray-700 text-center px-4 m-2 text-sm">🐍  4 D.S.</div><div class="text-gray-700 text-center px-4 m-2 text-sm"><strong>Version:</strong> <!-- -->SP21</div></div><div class="text-gray-700 mt-2 text-center text-sm font-bold">All Rights Reserved Michael Haberman</div><div class="text-gray-700 text-center text-sm">Do not distribute this notebook</div></div></div></div><div> </div><div class="ide code-starter clearfix"><pre><code># print(ide.tester.test_notebook()) 
# print(ide.tester.test_notebook(verbose=True)) 

# once you are ready -- run this 
# ide.tester.download_solution() 
</code></pre></div><h1 class="section" id="section6">Appendix.</h1><p class="new">The following are the numbers run though finding<em>characters</em>v(1|2) but with the additional cleaning and normalizing</p><pre><code>#v1
[('Harry', 1326), ('Ron', 429), ('Hagrid', 370), ('Hermione', 269), ('Professor', 180), ('Snape', 172), 
('Dumbledore', 156), ('Dudley', 138), ('Malfoy', 122), ('Neville', 117), ('Vernon', 116), ('Quirrell', 112), 
('Uncle', 111), ('Potter', 102), ('McGonagall', 101), ('Gryffindor', 82), ('Hogwarts', 76), ('Quidditch', 59), 
('Stone', 58), ('Petunia', 58), ('Wood', 55), ('Dursley', 54), ('Aunt', 52), ('Filch', 52), ('Dursleys', 50), 
('Slytherin', 49), ('Weasley', 47), ('Yes', 42), ('Percy', 38), ('Voldemort', 36), 
("Don't", 34), ('Fred', 34), ('Peeves', 33), ('George', 30), ('Great', 27), ('Gringotts', 27), 
('Flamel', 27), ('Fluffy', 26), ('Norbert', 26), ('Christmas', 25)] 

#v2
[('Uncle Vernon', 108), ('Professor McGonagall', 95), ('Aunt Petunia', 51), ('Harry Potter', 29), 
('Mr Dursley', 29), ('Professor Dumbledore', 22), ('Mrs Dursley', 19), ('Professor Quirrell', 18), 
('Mr Potter', 17), ('Hermione Granger', 17), ('Privet Drive', 16), ('Mr Ollivander', 16), 
('Great Hall', 15), ('Professor Flitwick', 15), ('Sorcerer Stone', 13), ('Madam Pomfrey', 13), 
('Mrs Norris', 13), ('Nicolas Flamel', 12), ('Madam Hooch', 12), ('Harry Ron', 12), 
('Harry Harry', 10), ('Leaky Cauldron', 10), ('Draco Malfoy', 9), ('Albus Dumbledore', 8), 
('Mrs Figg', 8), ('Lee Jordan', 8), ('George Weasley', 8), ('Professor Snape', 8), 
('Fat Lady', 8), ('Dark Arts', 7), ('Diagon Alley', 7), ('Madam Malkin', 7), ('Miss Granger', 7), 
('Hagrid Harry', 6), ('King Cross', 6), ('Potter Harry', 6), ('Flavor Beans', 6), ('Chocolate Frogs', 6), 
('High Table', 6), ('Seamus Finnigan', 6)]</code></pre></div></div></body></html>