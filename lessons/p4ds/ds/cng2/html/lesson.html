<!DOCTYPE html><html lang='en'><head><title>Cliff Note Generator</title><meta charset="utf-8"><style>/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}h1{font-size:2em;margin:.67em 0}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}strong{font-weight:bolder}code{font-family:monospace,monospace;font-size:1em}img{border-style:none}input{font-family:inherit;font-size:100%;line-height:1.15;margin:0}input{overflow:visible}[type=checkbox]{box-sizing:border-box;padding:0}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}h1,h2,h3,p,pre{margin:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e2e8f0}img{border-style:solid}input:-ms-input-placeholder{color:#a0aec0}input::-ms-input-placeholder{color:#a0aec0}input::-moz-placeholder{color:#a0aec0}h1,h2,h3{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}input{padding:0;line-height:inherit;color:inherit}code,pre{font-family:Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}img{display:block;vertical-align:middle}img{max-width:100%;height:auto}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}.bg-gray-200{--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.bg-gray-300{--bg-opacity:1;background-color:#e2e8f0;background-color:rgba(226,232,240,var(--bg-opacity))}.bg-orange-300{--bg-opacity:1;background-color:#fbd38d;background-color:rgba(251,211,141,var(--bg-opacity))}.bg-green-200{--bg-opacity:1;background-color:#c6f6d5;background-color:rgba(198,246,213,var(--bg-opacity))}.bg-blue-200{--bg-opacity:1;background-color:#bee3f8;background-color:rgba(190,227,248,var(--bg-opacity))}.bg-blue-300{--bg-opacity:1;background-color:#90cdf4;background-color:rgba(144,205,244,var(--bg-opacity))}.border-gray-400{--border-opacity:1;border-color:#cbd5e0;border-color:rgba(203,213,224,var(--border-opacity))}.border-gray-500{--border-opacity:1;border-color:#a0aec0;border-color:rgba(160,174,192,var(--border-opacity))}.border-indigo-500{--border-opacity:1;border-color:#667eea;border-color:rgba(102,126,234,var(--border-opacity))}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.border-solid{border-style:solid}.border-l-2{border-left-width:2px}.border-t{border-top-width:1px}.cursor-pointer{cursor:pointer}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.justify-center{justify-content:center}.justify-around{justify-content:space-around}.clearfix:after{content:"";display:table;clear:both}.font-sans{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"}.font-serif{font-family:Georgia,Cambria,"Times New Roman",Times,serif}.font-semibold{font-weight:600}.font-bold{font-weight:700}.h-64{height:16rem}.text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-base{font-size:1rem}.text-xl{font-size:1.25rem}.leading-none{line-height:1}.leading-normal{line-height:1.5}.m-2{margin:.5rem}.my-4{margin-top:1rem;margin-bottom:1rem}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.mr-2{margin-right:.5rem}.mb-2{margin-bottom:.5rem}.mb-3{margin-bottom:.75rem}.mt-4{margin-top:1rem}.mb-4{margin-bottom:1rem}.mt-6{margin-top:1.5rem}.max-w-sm{max-width:24rem}.max-w-2xl{max-width:42rem}.object-contain{-o-object-fit:contain;object-fit:contain}.opacity-0{opacity:0}.overflow-hidden{overflow:hidden}.p-1{padding:.25rem}.p-3{padding:.75rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pl-3{padding-left:.75rem}.absolute{position:absolute}.shadow-md{box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06)}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}.shadow-inner{box-shadow:inset 0 2px 4px 0 rgba(0,0,0,.06)}.text-left{text-align:left}.text-center{text-align:center}.text-black{--text-opacity:1;color:#000;color:rgba(0,0,0,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-800{--text-opacity:1;color:#2d3748;color:rgba(45,55,72,var(--text-opacity))}.whitespace-no-wrap{white-space:nowrap}.w-1\/2{width:50%}.w-2\/3{width:66.666667%}.w-full{width:100%}@media (min-width:768px){.md\:w-2\/3{width:66.666667%}}.text-tiny{font-size:.5rem!important}body{color:#000!important;font-size:1.25rem!important}.main-content{max-width:900px}.lesson{padding-left:15px!important;padding-right:10px!important;--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.main-content,html{font-family:Arial,Georgia,Verdana,"Times New Roman"!important}.lesson-footer-card,.lesson-overview-card{font-family:"Times New Roman"!important}.lesson-footer{margin-top:50px;margin-top:20px}.lesson ol{list-style-type:decimal;list-style-position:inside;margin-left:1em}.lesson ul{list-style-position:inside;list-style-type:none;margin-left:1em}.lesson ul li{padding-left:1em;padding-right:5px}.lesson ul li::before{content:"‚Ä¢";padding-right:5px}span{white-space:nowrap}p.new{padding-top:0;padding-bottom:.5em}p.new+p{padding-top:.5em}h1,h2,h3{font-weight:700;margin-top:.25em!important;margin-bottom:.05em!important;font-family:Georgia,Cambria,"Times New Roman",Times,serif!important}h1{font-size:2em!important;clear:both;color:#000!important}div+h1,h2{margin-top:0!important}h2{margin-top:.5em!important;font-size:1.5em!important;clear:both;color:#8b0000!important}h3{font-size:1.25em!important;clear:both;color:#006400!important}ul{margin-bottom:30px}.lesson a{text-decoration:underline;color:#00f}.title-text{font-size:2rem}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.5)}code{font-size:smaller}pre code{font-size:15px}pre code:not(.line-number){background:#f4f4f4;font-family:monospace;font-size:15px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;touch-action:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;clear:both;border:1px solid #ddd;color:#666;page-break-inside:avoid;display:block;min-width:840px;max-width:840px;overflow:scroll;line-height:1.6;margin-bottom:1.6em;padding:1em 1.5em;-moz-tab-size:2;-o-tab-size:2;tab-size:2;word-wrap:break-word;white-space:pre-wrap;border-left:3px solid #f36d33}div.code-starter>pre code{border-left:3px solid #fdff44!important;background-image:radial-gradient(rgba(0,150,0,.75),#000 120%);color:#fff;font:.9rem Inconsolata,monospace}div.code-starter>pre code::after{content:"\a$_"}.tab{font-size:1rem;border-color:#8c6728}.tab-content{max-height:0;max-width:100%;transition:max-height .35s}.tab input:checked~.tab-content{max-height:100vh}.tab input:checked+label{padding:1rem;border-left-width:2px;border-color:#6574cd;background-color:#f8fafc;color:#6574cd}.tab label::after{float:right;right:0;top:0;display:block;width:1em;height:1.5em;line-height:1.5;font-size:1rem;text-align:center;transition:all .35s}.tab input[type=checkbox]+label::after{content:"+";font-weight:700;border-width:1px;border-radius:9999px;border-color:#8c6728}.tab input[type=checkbox]:checked+label::after{transform:rotate(315deg);background-color:#6574cd;color:#f8fafc}</style>
<script src="https://kit.fontawesome.com/7efc4bcee2.js" crossOrigin="anonymous"></script>
<script>
    let stateCheck = setInterval(function(){
      if (document.readyState === 'complete') {
        clearInterval(stateCheck);
        let s1 = document.getElementById('start');
        // console.log('doc is ready', s1);
        if (s1) {
           s1.setAttribute('tabindex', '-1');
           s1.focus(); 
           s1.scrollIntoView({behavior: 'smooth'}); 
           setTimeout(function(){s1.blur()}, 500);
           // console.log('focus set');
        }
      }
    }, 200);
    </script>
</head><body class="lesson"><div class="main-content lesson bg-gray-200 text-black p-1 pl-3 font-serif"><div class="md-inner">
<div id="start" class="section">&nbsp;</div><h1 class="overview"></h1><div class="lesson-overview bg-gray-200 flex justify-center"><div class="text-center px-4 py-2 m-2"><div class="lesson-overview-card displaycard bg-blue-200 max-w-sm rounded overflow-hidden shadow-lg"><div>¬†</div><img alt="Text" class="object-contain h-64 w-full" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/ds/cng2/html/ds-sm.png"/><div class="px-6 py-4"><div class="title-text text-center leading-none font-bold text-xl">Cliff Note Generator</div><p class="text-center mt-2 text-gray-800 text-xl">Cleaning Continued</p><div class="text-gray-700 text-base">¬†</div><div class="text-center mb-3"><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#info490</span></div><div class="flex border-t border-solid border-gray-500 shadow-inner justify-around bg-blue-300"><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap">üêç¬†¬†4 D.S.</span></div><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap"><strong>Version:</strong> <!-- -->SP21</span></div></div><div class="text-gray-700 mt-1 text-center text-tiny">All Rights Reserved</div></div></div></div><div class="text-center px-4 py-2 m-2 w-1/2"><div class="displaycard bg-gray-200 max-w-sm rounded overflow-hidden shadow-lg"><div class="px-6 py-4 text-left"><div class="text-center font-bold text-xl">Cliff Note Generator<br/><div><span>prerequisites</span><div class="text-center text-xs mb-2">(start only after finishing)</div><p class="max-w-sm text-gray-800 text-sm">‚¶ø <strong>bootcamp</strong></p><p class="max-w-sm text-gray-800 text-sm">‚¶ø <strong>local I/O</strong></p><p class="max-w-sm text-gray-800 text-sm">‚¶ø <strong>array slicing</strong></p></div></div></div><div class="px-6 py-4 text-left text-gray-800"><div class="text-center font-bold text-xl">Colab Notes</div><p class="max-w-sm text-sm">1. <strong>Copy</strong> this notebook <img alt="copy2drive.png" class="inline-block" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/ds/cng2/html/copy2drive.png"/></p><p class="max-w-sm text-sm">2. <strong>Update</strong> the <strong><code>NET_ID</code></strong> in the notebook</p><p class="max-w-sm text-gray-800 text-sm">3. <strong>Hit ‚ñ∂Ô∏è¬†</strong> to install the INFO 490 IDE</p><div class="text-center font-bold text-xl">¬†</div><div class="text-center font-bold text-xl">Jupyter/PyCharm Notes</div><p class="max-w-sm text-gray-800 text-sm text-left">The testing framework does <strong>not work</strong> (at this time) for Jupyter  notebooks or local code development.</p></div></div></div></div><h1 class="section" id="section1">Cliff Note Generator</h1><h2 id="cleaning-continued">Cleaning Continued</h2><p class="new">In the previous lesson we wrote a very simple parser for dealing with a 
string of text.  Our first attempt to split the text into words had a lot to 
be desired.  In the last lesson, you were asked to list all the issues with the 
method used to split the text.  Here's my list:</p><ul><li>some words had punctuation: e.g. 'widow,'</li><li>'double words: e.g. 'is--and'</li><li>blank words: e.g.  ' '  (if you used the split(' ') method)</li><li>the words 'YOU' and 'you' (not a problem with the splitting, but a problem
that needs to be addressed) should be treated as the same word</li></ul><p class="new">The list becomes longer if you parse the entire book -- which we will get to soon.</p><h2 id="tokens">Tokens</h2><p class="new">The word token is used to represent a sequence of characters that have some 
kind of meaning.  For doing text analysis, a token is usually a word, but 
punctuation and whitespace -- which usually separate words -- are also tokens. 
Since we are interested in getting words (as opposed to punctuation or currency 
or phrases), tokens are synonymous with words for our discussion.</p><h2 id="fixing-the-parser">Fixing the parser.</h2><p class="new">The results of the parser we used to split the words can be fixed by one of 
three methods:</p><ol start="1"><li>pre-process the input</li><li>post-process the output</li><li>build a more robust parser</li></ol><h3 id="pre-process-the-input">Pre-process the input</h3><p class="new">If the parser can't be changed (it will use <code>split()</code>) we can help that 
functionality by replacing any punctuation with spaces (so "Hi! Tom, 
how are you?" becomes "Hi Tom how are you ", and splitting on that will work fine. 
However, you need to be careful.  For words that are contracted (e.g. ain't) 
or hyphenated (e.g. well-water, can-not, etc), you will have to make the 
decision on how to handle those.  Some analyses will want to keep the 
punctuation; others may remove or replace the contracted words with 
several words or a single word.</p><h3 id="post-process-the-output">Post-process the output</h3><p class="new">In some cases, it might be easier to clean up the output of the parser. 
In this example, you could loop through the tokens and remove, replace, 
or fix the issues.  You will have to decide which solution is more robust 
or easier to implement.  Since some tokens were really two words (e.g. is--and) 
separating them and then adding each component back into the token list is a bit of more work.</p><p class="new">Usually you will want a generalized solution such that you don't have to make 
modifications to your code as you process more text.   For example, you 
could have a giant selection statement that does something like the following:</p><pre><code>output = parse(text)
for word in output:
  if word == 'is--and':
    # do something
  if word == 'book,':
    # do something</code></pre><p class="new">This is called a hard coded solution.  It might work for one chunk of text, 
but it surely won't work for a different book.  It's not a scalable solution. 
You could 'fix' this by testing for different patterns (does the word have a '--' in it?, 
does the word end in a ','. This is an improvement, but you are still left 
with a bunch of specific rules, what you want is to come up with a 
general set of rules that would apply to almost all text documents.</p><h3 id="building-a-better-parser">Building a Better Parser</h3><p class="new">Our simple parser could be improved by splitting the text using both 
spaces (called whitespace -- tabs, newlines, spaces) and punctuation. If the 
token is a space or punctuation, then the input is split into two parts. 
When you want to perform an action based on a pattern match, you need to 
use a tool called <em>regular expressions</em>.</p><p class="new">Regular expressions allow you to find, replace, delete, and to test for any text 
that matches a pattern.  For example, if you define a word as only 
containing letters, then the regular expression for that pattern is <code>[A-Za-z]+</code>. 
The square brackets denote a set of character classes; <code>A-Z</code> is the set of 
uppercase letters, <code>a-z</code> is the set of lowercase letters.  The <code>+</code> sign at the 
end means a sequence of 1 or more of the preceding pattern. If you wanted to 
match numbers you could use the regular expression (regex for short) <code>[0-9]+</code> (you would 
read this as 1 or more characters from the range 0 through 9).</p><p class="new">However, mastering regular expressions will take us on a journey that 
would detract from our main goal: getting through this example.  We will 
revisit regular expressions in an upcoming lesson.  </p><h2 id="cleansing-data">Cleansing Data</h2><p class="new">A closely related topic to cleaning the data in preparation for analysis is 
the idea of cleansing the data -- detecting and correcting data quality issues. 
The focus here is on fixing <strong>corrupt data</strong>, <strong>inconsistent data</strong> (merging data 
from two different sources that use different data management schemes), 
<strong>inaccurate data</strong>, <strong>irrelevant data</strong> (remove useless or redundant attributes 
in the data), dirty data (where data was wrongly ingested), <strong>typographical errors</strong>, 
<strong>incomplete data</strong>. Many of these issues are relevant when the data 
is coming from people (think survey data -- free form response). People may 
be saying the same thing, but if it doesn't get coded in a consistent way, your analysis will suffer.</p><h2 id="normalizing-tokens">Normalizing Tokens</h2><p class="new">Once we are done with parsing and cleaning, we need to further 
process the data for our specific analysis (word counts). For many text 
analysis projects it's important to normalize the data.  That is to put the data 
into a format that removes differences that would affect our analysis. In 
this case the words 'You', 'you', and 'YOU' should really be considered the 
same word.  Not only are you trying to get an accurate analysis, but you can 
also speed up the project by not having to consider so many different versions 
of the same 'word'.  Sometimes this is called data standardization.</p><p class="new">Additional normalization may include stemming -- which attempts to take 
different forms of a word and reduce them to their common root. For example, 
<strong>work</strong>, <strong>working</strong>, <strong>worked</strong>, <strong>works</strong> could all map to the word <strong>work</strong>. 
Other normalization techniques include spell correcting, spell 
normalization (e.g. changing can not to cannot), removal of common 
words (called <strong>stop words</strong>) or stop lists).  Also expanding contractions 
might be necessary (e.g. changing can't to cannot).  Each of these has a 
cost (time, money, inaccuracy) and a benefit (time, money, accuracy). 
The question you need to ask yourself is what normalization would be useful and at what cost.</p><p class="new">For our purposes, the only normalization you should do is to ignore differences 
in case.  So the words 'You' and 'YOU' are treated as the same word. This includes 
single letters capitalized in the middle of a word (e.g. You bET).  </p><h2 id="when-to-normalize">When to normalize</h2><p class="new">Moving the text to a normalized form can be done before, after, during the 
parsing of the information.  It's really up to the data scientist to 
understand the trade-offs of when to normalize the data (the same situation 
we discussed for cleaning).  </p><p class="new">Don't get too hung up on whether this process is actually cleaning the data or 
is it normalizing the data. If the process of cleaning the data, puts it into 
a format that further processes down the pipeline can assume, then that 
cleaning is part of data normalization.</p><div class="font-sans container mt-1 mb-4 "><p>üéóBefore you go, you should <strong>know</strong>:</p><div class="w-2/3 md:w-2/3"><div class="shadow-md"><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-0" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-0"><span> When and why do we have to parse the data? </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-1" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-1"><span> What is cleansing and normalizing the data? </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div></div></div></div><h1 class="section" id="section2">Lesson Assignment</h1><h2 id="step-1-">Step 1. </h2><p class="new">Finish the definitions for all the functions in the next code cell such that you
can clean and parse the text inside the variable <code>sample_text</code> into a list of tokens.</p><div class="ide code-starter clearfix"><pre><code>def parse(input):
  # input is a string
  # returns a list of tokens
  return []
  
def pre_clean(t):
  # t is a string
  # remove all punctuation from the parameter t
  # however, keep single quotes.
  # so contracted words have the quote still
  # this comes at a cost of single quoted words
  # will stay:  I love fast 'food'.
  # this could be dealt in a subsequent cleaning
  # stage if necessary
  return t

def normalize(t):
  return t
  
  
# Now test it
sample_text = "YOU don't know about me without you have read a book by the name of The Adventures of Tom Sawyer; but that ain't no matter.  That book was made by Mr. Mark Twain, and he told the truth, mainly.  There was things which he stretched, but mainly he told the truth.  That is nothing.  I never seen anybody but lied one time or another, without it was Aunt Polly, or the widow, or maybe Mary.  Aunt Polly--Tom's Aunt Polly, she is--and Mary, and the Widow Douglas is all told about in that book, which is mostly a true book, with some stretchers, as I said before."</code></pre></div><p class="new">Be sure to test your functions before moving to the next step.  Use the
 <code>sample_text</code>.  The <code>ide.tester</code> has no tests for individual functions.</p><h2 id="step-2-implement-the-function-pipelinetext">Step 2. Implement the function <code>pipeline(text)</code></h2><p class="new">Note the order of the stages:  </p><ol start="1"><li>clean the input (using <code>pre_clean</code>),  (see comments in code)</li><li>parse the input (using <code>parse</code>)</li><li>normalize the input (using <code>normalize</code>) its input from <code>parse</code></li></ol><p class="new">Note you will need to <em>read</em> this lesson as it specifies what to do.</p><p class="new">So <code>pre_clean</code> can help your parser (that's a hint). Be sure to have <code>pipeline</code> 
return the list of processed tokens (see code cell comments). You should have 
each stage of the pipeline saved into a variable (so no need for nested function calls).</p><div class="ide code-starter clearfix"><pre><code># you can define more functions as well  
def pipeline(text):
  # call the different stages of
  # cleaning, parsing, normalizing
  # you can add additional helper functions too
  # return the results as a list
  return []</code></pre></div><p class="new">Hints for cleaning/normalizing the text:</p><ul><li>look at string module (<a href="https://docs.python.org/3.6/library/string.html" target="_blank">https://docs.python.org/3.6/library/string.html</a>) it
has some of the common character sets (including punctuation). You can modify those strings as well to suit your needs.</li><li>Do NOT use any regular expressions for parsing, cleaning, etc.</li><li>After you are done, if you send <code>sample_text</code> through your <code>pipeline()</code>, you 
should get 108 total tokens.</li><li>As a bonus, can you figure out (using Python) how many unique tokens there are? (hint: 66)</li></ul><h1>Test and Submit</h1><p>Once you have finished, you can download your code (via <code>ide.tester</code>) and upload that file to Gradescope (find lesson with tag <strong>DS-CNG-CLEAN</strong>).</p><div class="my-4"><pre><code><strong># to list the tests available</strong><br/>print(ide.tester.list_tests())<br/><strong># to perform a specific test</strong><br/>print(ide.tester.test_functionality('name of test'))<br/><strong># to test your code (either works)</strong><br/>print(ide.tester.test_notebook())<br/>print(ide.tester.test_notebook(verbose=True))<br/><strong># to prepare and download your code</strong><br/>ide.tester.download_solution()</code></pre></div><div class="lesson-footer flex bg-gray-200 justify-center"><div class="lesson-footer-card displaycard bg-blue-200 border-t border-gray-400 max-w-2xl rounded overflow-hidden shadow-lg"><div class="px-6 py-4"><div class="title-text text-center font-bold text-xl">Cliff Note Generator</div><p class="text-center text-gray-800 text-xl">Cleaning Continued</p><div class="text-center mt-6 text-xl"><i aria-hidden="true" class="fas fa-tags"></i> any questions on Piazza with <span class="font-bold">DS-CNG-CLEAN</span></div><div class="text-gray-700 text-base">¬†</div><div></div><div></div><div class="flex mt-4 border-t border-solid border-gray-500 justify-around bg-gray-200"><div class="text-gray-700 text-center px-4 m-2 text-sm">üêç¬†¬†4 D.S.</div><div class="text-gray-700 text-center px-4 m-2 text-sm"><strong>Version:</strong> <!-- -->SP21</div></div><div class="text-gray-700 mt-2 text-center text-sm font-bold">All Rights Reserved Michael Haberman</div><div class="text-gray-700 text-center text-sm">Do not distribute this notebook</div></div></div></div><div>¬†</div><div class="ide code-starter clearfix"><pre><code># print(ide.tester.test_notebook()) 
# print(ide.tester.test_notebook(verbose=True)) 

# once you are ready -- run this 
# ide.tester.download_solution() 
</code></pre></div></div></div></body></html>