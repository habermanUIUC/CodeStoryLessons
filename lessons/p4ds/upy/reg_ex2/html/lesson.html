<!DOCTYPE html><html lang='en'><head><title>Regular Expressions (part 2)</title><meta charset="utf-8"><style>/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}h1{font-size:2em;margin:.67em 0}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}strong{font-weight:bolder}code{font-family:monospace,monospace;font-size:1em}img{border-style:none}input{font-family:inherit;font-size:100%;line-height:1.15;margin:0}input{overflow:visible}[type=checkbox]{box-sizing:border-box;padding:0}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}blockquote,h1,h2,h3,h4,p,pre{margin:0}ol,ul{list-style:none;margin:0;padding:0}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e2e8f0}img{border-style:solid}input:-ms-input-placeholder{color:#a0aec0}input::-ms-input-placeholder{color:#a0aec0}input::-moz-placeholder{color:#a0aec0}h1,h2,h3,h4{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}input{padding:0;line-height:inherit;color:inherit}code,pre{font-family:Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}img{display:block;vertical-align:middle}img{max-width:100%;height:auto}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}.bg-gray-200{--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.bg-gray-300{--bg-opacity:1;background-color:#e2e8f0;background-color:rgba(226,232,240,var(--bg-opacity))}.bg-orange-300{--bg-opacity:1;background-color:#fbd38d;background-color:rgba(251,211,141,var(--bg-opacity))}.bg-green-200{--bg-opacity:1;background-color:#c6f6d5;background-color:rgba(198,246,213,var(--bg-opacity))}.bg-blue-200{--bg-opacity:1;background-color:#bee3f8;background-color:rgba(190,227,248,var(--bg-opacity))}.bg-blue-300{--bg-opacity:1;background-color:#90cdf4;background-color:rgba(144,205,244,var(--bg-opacity))}.border-gray-400{--border-opacity:1;border-color:#cbd5e0;border-color:rgba(203,213,224,var(--border-opacity))}.border-gray-500{--border-opacity:1;border-color:#a0aec0;border-color:rgba(160,174,192,var(--border-opacity))}.border-indigo-500{--border-opacity:1;border-color:#667eea;border-color:rgba(102,126,234,var(--border-opacity))}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.border-solid{border-style:solid}.border-l-2{border-left-width:2px}.border-t{border-top-width:1px}.cursor-pointer{cursor:pointer}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.justify-center{justify-content:center}.justify-around{justify-content:space-around}.clearfix:after{content:"";display:table;clear:both}.font-sans{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"}.font-serif{font-family:Georgia,Cambria,"Times New Roman",Times,serif}.font-semibold{font-weight:600}.font-bold{font-weight:700}.h-64{height:16rem}.text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-base{font-size:1rem}.text-xl{font-size:1.25rem}.leading-none{line-height:1}.leading-normal{line-height:1.5}.m-2{margin:.5rem}.my-4{margin-top:1rem;margin-bottom:1rem}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.mr-2{margin-right:.5rem}.mb-2{margin-bottom:.5rem}.mb-3{margin-bottom:.75rem}.mt-4{margin-top:1rem}.mb-4{margin-bottom:1rem}.mt-6{margin-top:1.5rem}.max-w-sm{max-width:24rem}.max-w-2xl{max-width:42rem}.object-contain{-o-object-fit:contain;object-fit:contain}.opacity-0{opacity:0}.overflow-hidden{overflow:hidden}.p-1{padding:.25rem}.p-3{padding:.75rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pl-3{padding-left:.75rem}.absolute{position:absolute}.shadow-md{box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06)}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}.shadow-inner{box-shadow:inset 0 2px 4px 0 rgba(0,0,0,.06)}.text-left{text-align:left}.text-center{text-align:center}.text-black{--text-opacity:1;color:#000;color:rgba(0,0,0,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-800{--text-opacity:1;color:#2d3748;color:rgba(45,55,72,var(--text-opacity))}.whitespace-no-wrap{white-space:nowrap}.w-1\/2{width:50%}.w-2\/3{width:66.666667%}.w-full{width:100%}@media (min-width:768px){.md\:w-2\/3{width:66.666667%}}.text-tiny{font-size:.5rem!important}body{color:#000!important;font-size:1.25rem!important}.main-content{max-width:900px}.lesson{padding-left:15px!important;padding-right:10px!important;--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.main-content,html{font-family:Arial,Georgia,Verdana,"Times New Roman"!important}.lesson-footer-card,.lesson-overview-card{font-family:"Times New Roman"!important}.lesson-footer{margin-top:50px;margin-top:20px}li>p{display:inline!important}.lesson ol{list-style-type:decimal;list-style-position:inside;margin-left:1em}.lesson ul{list-style-position:inside;list-style-type:none;margin-left:1em}.lesson ul li{padding-left:1em;padding-right:5px}.lesson ul li::before{content:"‚Ä¢";padding-right:5px}span{white-space:nowrap}p.new{padding-top:0;padding-bottom:.5em}p.new+p{padding-top:.5em}h1,h2,h3,h4{font-weight:700;margin-top:.25em!important;margin-bottom:.05em!important;font-family:Georgia,Cambria,"Times New Roman",Times,serif!important}h1{font-size:2em!important;clear:both;color:#000!important}div+h1,h2{margin-top:0!important}h2{margin-top:.5em!important;font-size:1.5em!important;clear:both;color:#8b0000!important}h3{font-size:1.25em!important;clear:both;color:#006400!important}h4{font-size:1em!important;clear:both;color:#00008b!important}ul{margin-bottom:30px}p.new a{text-decoration:underline}.lesson a{text-decoration:underline;color:#00f}.title-text{font-size:2rem}blockquote{font-size:1em;background:#f9f9f9;border-left:10px solid #ccc;margin:.5em 10px;padding:.5em 10px;border-left-color:#ffcd69;border-right-color:#f6ba59;quotes:"\201C""\201D""\2018""\2019"}blockquote:before{color:#ccc;content:open-quote;font-size:4em;line-height:.1em;margin-right:.25em;vertical-align:-.4em}blockquote:after{color:#ccc;content:no-close-quote}blockquote p{display:inline}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.5)}img.center{-o-object-position:center;object-position:center;margin-left:auto;margin-right:auto}code{font-size:smaller}pre code{font-size:15px}pre code:not(.line-number){background:#f4f4f4;font-family:monospace;font-size:15px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;touch-action:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;clear:both;border:1px solid #ddd;color:#666;page-break-inside:avoid;display:block;min-width:840px;max-width:840px;overflow:scroll;line-height:1.6;margin-bottom:1.6em;padding:1em 1.5em;-moz-tab-size:2;-o-tab-size:2;tab-size:2;word-wrap:break-word;white-space:pre-wrap;border-left:3px solid #f36d33}div.code-starter>pre code{border-left:3px solid #fdff44!important;background-image:radial-gradient(rgba(0,150,0,.75),#000 120%);color:#fff;font:.9rem Inconsolata,monospace}div.code-starter>pre code::after{content:"\a$_"}.tab{font-size:1rem;border-color:#8c6728}.tab-content{max-height:0;max-width:100%;transition:max-height .35s}.tab input:checked~.tab-content{max-height:100vh}.tab input:checked+label{padding:1rem;border-left-width:2px;border-color:#6574cd;background-color:#f8fafc;color:#6574cd}.tab label::after{float:right;right:0;top:0;display:block;width:1em;height:1.5em;line-height:1.5;font-size:1rem;text-align:center;transition:all .35s}.tab input[type=checkbox]+label::after{content:"+";font-weight:700;border-width:1px;border-radius:9999px;border-color:#8c6728}.tab input[type=checkbox]:checked+label::after{transform:rotate(315deg);background-color:#6574cd;color:#f8fafc}</style>
<script src="https://kit.fontawesome.com/7efc4bcee2.js" crossOrigin="anonymous"></script>
<script>
    let stateCheck = setInterval(function(){
      if (document.readyState === 'complete') {
        clearInterval(stateCheck);
        let s1 = document.getElementById('start');
        // console.log('doc is ready', s1);
        if (s1) {
           s1.setAttribute('tabindex', '-1');
           s1.focus(); 
           s1.scrollIntoView({behavior: 'smooth'}); 
           setTimeout(function(){s1.blur()}, 500);
           // console.log('focus set');
        }
      }
    }, 200);
    </script>
</head><body class="lesson"><div class="main-content lesson bg-gray-200 text-black p-1 pl-3 font-serif"><div class="md-inner">
<div id="start" class="section">&nbsp;</div><h1 class="overview"></h1><div class="lesson-overview bg-gray-200 flex justify-center"><div class="text-center px-4 py-2 m-2"><div class="lesson-overview-card displaycard bg-blue-200 max-w-sm rounded overflow-hidden shadow-lg"><div>¬†</div><img alt="Text" class="object-contain h-64 w-full" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/upy/reg_ex2/html/upy-sm.png"/><div class="px-6 py-4"><div class="title-text text-center leading-none font-bold text-xl">Regular Expressions (part 2)</div><p class="text-center mt-2 text-gray-800 text-xl">Finding patterns continued</p><div class="text-gray-700 text-base">¬†</div><div class="text-center mb-3"><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#info490</span><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#python</span></div><div class="flex border-t border-solid border-gray-500 shadow-inner justify-around bg-blue-300"><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap">üêç¬†¬†4 D.S.</span></div><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap"><strong>Version:</strong> <!-- -->SP21</span></div></div><div class="text-gray-700 mt-1 text-center text-tiny">All Rights Reserved</div></div></div></div><div class="text-center px-4 py-2 m-2 w-1/2"><div class="displaycard bg-gray-200 max-w-sm rounded overflow-hidden shadow-lg"><div class="px-6 py-4 text-left"><div class="text-center font-bold text-xl">Regular Expressions (part 2)<br/><div><span>prerequisites</span><div class="text-center text-xs mb-2">(start only after finishing)</div><p class="max-w-sm text-gray-800 text-sm">‚¶ø <strong>bootcamp</strong></p><p class="max-w-sm text-gray-800 text-sm">‚¶ø <strong>array slicing</strong></p><p class="max-w-sm text-gray-800 text-sm">‚¶ø <strong>comprehensions</strong></p></div></div></div><div class="px-6 py-4 text-left text-gray-800"><div class="text-center font-bold text-xl">Colab Notes</div><p class="max-w-sm text-sm">1. <strong>Copy</strong> this notebook <img alt="copy2drive.png" class="inline-block" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/upy/reg_ex2/html/copy2drive.png"/></p><p class="max-w-sm text-sm">2. <strong>Update</strong> the <strong><code>NET_ID</code></strong> in the notebook</p><p class="max-w-sm text-gray-800 text-sm">3. <strong>Hit ‚ñ∂Ô∏è¬†</strong> to install the INFO 490 IDE</p><div class="text-center font-bold text-xl">¬†</div><div class="text-center font-bold text-xl">Jupyter/PyCharm Notes</div><p class="max-w-sm text-gray-800 text-sm text-left">The testing framework does <strong>not work</strong> (at this time) for Jupyter  notebooks or local code development.</p></div></div></div></div><h1 class="section" id="section1">Regular Expressions (part 2)</h1><h2 id="finding-patterns-continued">Finding patterns continued</h2><p class="new">This is the second part of using regular expressions to easily find and use 
patterns in text. As we have seen they are a powerful tool for processing text 
by letting you describe a pattern for which data you are interested in. You 
can use regular expressions for </p><ul><li>cleaning text: replacing characters, removing characters</li><li>parsing text: splitting text into sentences, words, and tokens (like dates, airport codes, capitalized words, words with hyphens, etc)</li><li>testing text: asking if text has a vowel, is a number, a date, etc</li><li>searching for text that matches a pattern</li></ul><p class="new">The effort to learn regular expressions is well worth it -- almost all 
programming languages support regular expressions, you can even use regular 
expressions in some editors and on the "command line" (something we hope to cover).  </p><p class="new">The following reference from part 1 is repeated here:</p><h2 id="character-sets">Character Sets</h2><pre><code>[abc]   matches a or b or c
[abc]+  matches any combination of the letters: a, b, c 
[^abc]  matches anything BUT a or b or c 
        the caret 'negates' the characters that follow
^ - ] \ these 4 have special meaning and you will need to escape inside [ ]</code></pre><h2 id="matching-specific-counts-of-characters">Matching Specific Counts of Characters</h2><pre><code>?     0 or 1 time
*     0 or more times
+     1 or more times
{m}   m times
{m,}  at least m times
{,n}  0 through n times (inclusive)
{m,n} m through n times (inclusive)</code></pre><h2 id="character-classes-and-special-symbols">Character Classes and Special Symbols</h2><pre><code>.  match any character except \n 
\. match the period
\? match the question mark
\s match whitespace \s+ one or more white spaces 
\S match non whitespace
\d match digits (same as [0-9])
\D non digits (same as [^0-9])
\w same as [a-zA-Z0-9_]+  (word character)
\W same as [^a-zA-Z0-9_]+ (non word character or non alphanumeric)
\' match a single quote
\" match a double quote</code></pre><h1 class="section" id="section2">New in this lesson</h1><p class="new">The following is a summary of some of the new topics we will cover in this lesson:</p><pre><code> ab|bc   Matches either ab or bc
 
 \b      Matches empty string at word boundary
 \B      Matches empty string not at word boundary
 
 ^       Matches the beginning of a line 
 $       Matches the end of the line</code></pre><h2 id="this-or-that-or-the-other-thing">This OR that or the other thing</h2><p class="new">In the previous lesson you were asked to create a pattern to match either <code>he</code> or <code>she</code>. 
The following are possible solutions:</p><pre><code> pattern = r'\s+[sh]+e\s+'  
 pattern = r'\s+s?he\s+'</code></pre><p class="new">Both find 2110 matches. Both versions required the \s+ be used to ensure 
partial words (e.g. sheep) were not matched. However, the first one is 
technically wrong since it also matches words like shhhhe. The second one 
works because we were able to leverage the common characters.  </p><p class="new">With regular expressions you can use the pipe character <code>|</code> to separate choices. 
This is called <em>alternation</em>.  For example:</p><div class="ide code-starter clearfix"><pre><code>import re
text = "He said breathe and she and the sheep did hehe"
pattern = r'he|she'
r = re.findall(pattern, text, re.IGNORECASE)
print(r)</code></pre></div><p class="new"> 
Here are the matches:</p><pre><code> ['He', 'he', 'she', 'he', 'she', 'he', 'he']</code></pre><p class="new"><strong>He</strong> said breat<strong>he</strong> and <strong>she</strong> and the <strong>she</strong>ep did <strong>hehe</strong></p><p class="new">We can fix the above issues once we learn about word boundaries.</p><h2 id="finding-vowels">Finding Vowels</h2><p class="new">Let's start this lesson with an attempt to find all words in the text that 
have two consecutive vowels. With regular expressions, the task is quite easy. 
Let's write a pattern to find any word that contains two consecutive vowels:</p><div class="ide code-starter clearfix"><pre><code>def find_vowels(text):
   pattern = r'[a-z]*[aeiou]{2}[a-z]*'
   regex   = re.compile(pattern, re.IGNORECASE)
   return(regex.findall(text))</code></pre></div><p class="new"> 
Here's a description of the parts of pattern:</p><ul><li><code>[a-z]</code> is any letter, a through z</li><li><code>*</code> means zero or more of the previous character class</li><li><code>{2}</code> means 2 of the previous character class (vowels)</li><li><p class="new">use the <code>re.IGNORECASE</code> flag to keep the pattern simple -- it matches both
upper and lowercase</p><p class="new">You would describe the pattern as trying to match 0 or more letters, followed 
by exactly 2 vowels followed by 0 or more letters.</p></li></ul><div class="ide code-starter clearfix"><pre><code>import LessonUtil as Util
def vowel_demo():
    txt  = Util.read_huck()
    uniq = list(Util.get_uniq_set(find_vowels(txt)))
    print(uniq[0:20], len(uniq))</code></pre></div><p class="new">You should get 1529 words with two consecutive vowels.</p><h2 id="starting-vowels">Starting Vowels</h2><p class="new">How about words that begin with two consecutive vowels?  </p><div class="ide code-starter clearfix"><pre><code>import LessonUtil as Util
def find_vowels_starts(text):
    pattern = r'[aeiou]{2}[a-z]*'
    regex   = re.compile(pattern, re.IGNORECASE)
    return(regex.findall(text))
 
def test_starting_vowels():
    v    = find_vowels_starts(Util.read_huck())
    uniq = list(Util.get_uniq_set(v))
    print(uniq[0:20], len(uniq))</code></pre></div><p class="new"> 
We find 767 matches, but there are some issues. </p><h2 id="word-boundaries">Word Boundaries</h2><p class="new">We get words like 'oody' and 'oollishness'. The problem is that we are 
matching partial words.  We can augment the regular expression with 
a word boundary special character.  </p><p class="new">In Python, there is an idea of a word boundary which has the following definition:  </p><blockquote><p class="new">A word boundary <strong>matches the empty string</strong>, but only at the beginning or 
end of a word. A word is defined as a sequence of alphanumeric or underscore 
characters, so the end of a word is indicated by whitespace or a 
non-alphanumeric, non-underscore character.</p></blockquote><p class="new"> 
Let's update the pattern so that that it must start with a word boundary:</p><div class="ide code-starter clearfix"><pre><code>def find_vowels_starts(text):
    pattern = r'\b[aeiou]{2}[a-z]*'
    regex   = re.compile(pattern, re.IGNORECASE)
    return regex.findall(text)
 
v    = find_vowels_starts(Util.read_huck())
uniq = list(Util.get_uniq_set(v))
print(uniq[0:20], len(uniq))</code></pre></div><p class="new"> 
This gives us 65 complete matches.  </p><h4 id="zero-width-matching">zero-width matching</h4><p class="new">The thing to remember about word boundaries is that they <strong>match a zero-width character</strong>. 
They don‚Äôt cause the regular expression engine to advance through the string; 
instead, they consume no characters at all, and simply succeed or fail. </p><p class="new">For example, <code>\b</code> is an assertion that the current position is located at a 
word boundary; the position isn‚Äôt changed by the <code>\b</code> at all. This means that 
zero-width assertions should never be repeated, because if they match once at 
a given location, they will match an infinite number of times.</p><p class="new">So a word boundary will find those "words" that at least start with <code>[a-z0-9_]+</code> 
followed by whitespace or <code>[^0-9a-z_]</code>. Once it matches that location, it is 
up to whatever follows the <code>\b</code> in your regular expression to determine a match.</p><p class="new">If we wanted to match italicized double vowel words or phrases (e.g. <em>Aunt Polly!</em>), 
we would have to add the underscore to the pattern:</p><pre><code> pattern = r'\b_[aeiou]{2}[^_]*_'</code></pre><p class="new">The thing to note is the above expression <strong>will return</strong> the matching underscore 
and the set of words it finds will be a subset of the words found by the 
first regular expression <code>r'\b[aeiou]{2}[a-z]*'</code> and also include words that 
have non letters before the underscore as well.</p><p class="new">We can adjust the pattern to find the 69 words that <strong>end with two consecutive vowels</strong> (e.g kangaroo):</p><div class="ide code-starter clearfix"><pre><code>def find_vowels_ends(text):
    pattern = r'\b[a-z]*[aeiou]{2}\b'
    regex   = re.compile(pattern, re.IGNORECASE)
    return regex.findall(text)
 
v    = find_vowels_ends(Util.read_huck())
uniq = list(Util.get_uniq_set(v))
print(uniq[0:20], len(uniq))</code></pre></div><p class="new"> </p><h2 id="word-boundaries-with-he--she">Word Boundaries with he | she</h2><p class="new">Now we can address the previous issue with finding he and she:</p><div class="ide code-starter clearfix"><pre><code>def s_he_demo():
    text = "He said breathe and she and the sheep did hehe"
    pattern = r'he|she'
    r = re.findall(pattern, text, re.IGNORECASE)
    print(r)</code></pre></div><p class="new"> 
As we see, these are the matches:</p><pre><code>['He', 'he', 'she', 'he', 'she', 'he', 'he']</code></pre><p class="new"><strong>He</strong> said breat<strong>he</strong> and <strong>she</strong> and t<strong>he</strong> <strong>she</strong>ep did <strong>hehe</strong></p><h3 id="a-better-she">A better <code>s[he]</code></h3><p class="new">If you wanted to restrict the matching using word boundaries (or whitespace) 
you could do the following:</p><pre><code>pattern = r'\bhe|she\b'</code></pre><p class="new">However, we only get three matches:</p><pre><code>['He', 'she', 'he']</code></pre><p class="new"><strong>He</strong> said breathe and <strong>she</strong> and the sheep did <strong>he</strong>he</p><h3 id="using-parentheses">Using Parentheses</h3><p class="new">The alternation precedence is so low that the first <code>\b</code> is assumed to be part 
of the he and the final <code>\b</code> is assumed to follow any she. You can fix this 
by using parenthesis.  </p><p class="new">Parentheses are used to group matches. When you use them everything in the 
group is returned as a match:</p><pre><code>pattern = r'\b(he|she)\b'</code></pre><p class="new">Now we get the words we wanted:</p><pre><code>['He', 'she']</code></pre><p class="new"><strong>He</strong> said breathe and <strong>she</strong> and the sheep did hehe</p><p class="new">By using the parentheses, it gives you the ability to add pre or post matching 
characters: </p><div class="ide code-starter clearfix"><pre><code>text = "a telethon of a python coding marathon raised awareness of sleep state misperception"
pattern = r'\b(py|mara|tele)thon\b'
r = re.findall(pattern, text, re.IGNORECASE)
print(r)</code></pre></div><p class="new"> 
So if you are searching for a pattern but you want to capture the entire 
word (i.e. the context) that encapsulates the pattern, use word boundaries. </p><p class="new">The complement of <code>\b</code> is <code>\B</code> which means match the empty string at a 
non-word boundary. For example, if you wanted to find cat in the middle of a
 word:</p><pre><code>text = "the cat advocates to concatenate."
cat = re.findall(r'(\Bcat\B)', text)
print(cat)</code></pre><h2 id="finding-the-first-and-last">Finding the First and Last</h2><p class="new">Sometimes it's handy to be able to match the first item or last item in a body 
of text. For example, if we wanted to just match 'Dogs' in the following poem, we 
would do the following:</p><div class="ide code-starter clearfix"><pre><code>poem = '''\
I LIKE
Dogs
Black Dogs, Green Dogs
Bad Dogs, Mean Dogs
All kinds of Dogs
I like Dogs
Dogs
'''
 
def find_dogs(text):
    pattern = r'Dogs'
    regex   = re.compile(pattern)
    return regex.findall(text)
 
v = find_dogs(poem)
print("dogs:", len(v))</code></pre></div><p class="new"> 
But what if we wanted ONLY those Dogs that begin a line? The caret <code>^</code> can be 
used to indicate the start of a line of text:</p><div class="ide code-starter clearfix"><pre><code>def find_dogs(text):
    pattern = r'^Dogs'
    regex   = re.compile(pattern)
    return regex.findall(text)
    
poem = "Dogs I like Dogs\nDogs I am"
v = find_dogs(poem)
print("dogs:", len(v))</code></pre></div><p class="new"> 
The issue is the <code>^</code> will ONLY match the first item in a string. If you want 
to match all Dogs that begin a line (that is, after a newline), you must use 
the <code>re.M</code> or <code>re.MULTILINE</code> flag.</p><pre><code>regex = re.compile(pattern, re.M)</code></pre><h4 id="multiple-flags">Multiple Flags</h4><p class="new">If you need to pass multiple flags to the compile method you use the <code>|</code> 
(the or operator):</p><div class="ide code-starter clearfix"><pre><code>def find_dogs(text):
    pattern = r'^Dogs'
    regex   = re.compile(pattern, re.IGNORECASE | re.M)
    return regex.findall(text)
 
poem = "Dogs I like Dogs\ndogs I am"
v = find_dogs(poem)
print("dogs:", len(v))</code></pre></div><h4 id="-matching"><code>$</code> Matching</h4><p class="new">If you want to match words that END a line, you use the $ character:</p><div class="ide code-starter clearfix"><pre><code>poem = '''\
I LIKE
Dogs
Black Dogs, Green Dogs
Bad Dogs, Mean Dogs
All kinds of Dogs
I like Dogs
Dogs
'''

def find_dogs(text):
    pattern = r'Dogs$'
    regex   = re.compile(pattern, re.IGNORECASE | re.M)
    return regex.findall(text)
    
v = find_dogs(poem)
print("dogs:", len(v))</code></pre></div><p class="new"> 
So to get the Dogs that are the only word on a line:</p><pre><code>pattern = r'^Dogs$'</code></pre><h4 id="end-of-the-sentence-warning">End of the sentence warning</h4><p class="new">For analyzing text (including novels in Project Gutenberg) you cannot depend 
on multiline matching for determining the <strong>end of a sentence</strong> -- since the 
placement of the newline characters most likely depends on the format of the book. 
For example the pattern that finds any word with two vowels at the end of the line:</p><div class="ide code-starter clearfix"><pre><code>import LessonUtil as Util
def find_vowels_ends(text):
    pattern = r'[a-z]*[aeiou]{2}$'
    regex   = re.compile(pattern, re.M | re.IGNORECASE)
    return(regex.findall(text))
 
v = find_vowels_ends(Util.read_huck())
uniq = list(Util.get_uniq_set(v))
print(uniq[0:20])</code></pre></div><p class="new"> 
This only finds a few words.  On line 1178 prairie matches the above 
criteria only because the newline happened to be there.</p><h2 id="easy-practice">Easy Practice</h2><p class="new">There are several web based tools that you can use to build and test 
regular expressions easily.  Be sure to check out the following resources:</p><ul><li><a href="https://pythex.org" target="_blank">https://pythex.org</a></li><li><a href="https://regex101.com/#python" target="_blank">https://regex101.com/#python</a></li><li><a href="http://www.pyregex.com" target="_blank">http://www.pyregex.com</a></li></ul><p class="new">Be sure to read the <a href="https://docs.python.org/3.6/library/re.html" target="_blank">re documentation</a></p><div class="font-sans container mt-1 mb-4 "><p>üéóBefore you go, you should <strong>know</strong>:</p><div class="w-2/3 md:w-2/3"><div class="shadow-md"><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-0" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-0"><span> how the pipe operator works </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-1" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-1"><span> what a word boundary is </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-2" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-2"><span> how word boundaries do matching </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-3" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-3"><span> the meaning of <code>^</code></span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-4" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-4"><span> the meaning of <code>$</code></span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-5" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-5"><span> how <code>re.MULTILINE</code> works with <code>^</code> and <code>$</code></span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div></div></div></div><p class="new"> </p><h1 class="section" id="section3">Lesson Assignment</h1><p class="new">There are 2 sets of 5 questions to answer. You need to pass 4 of them in each
 set.</p><p class="new">The format for the answers will be the same as in the first (part 1) lesson
 on regular expressions</p><h2 id="huckleberry-finn">Huckleberry Finn</h2><p class="new">The following questions will use the text from Huckleberry Finn. </p><h3 id="hq0">h_q0:</h3><p class="new">How many words start with two consecutive vowels (a, e, i, o, u)</p><p class="new">Hint: 65 unique words</p><div class="ide code-starter clearfix"><pre><code>def h_q0():
  pattern = r''  
  # include any necessary flags too
  return re.compile(pattern, re.IGNORECASE)</code></pre></div><h4 id="testing">Testing</h4><p class="new">There's a few ways to test each of your questions.  Let's take üëÄ.</p><ol start="1"><li>You can build your one test</li></ol><pre><code>import LessonUtil as Util
huck = Util.read_huck()
def test_question(q_fn, text):
    regex = q_fn()
    tokens = regex.findall(text)
    uniq = Util.get_uniq_set(tokens)
    print(len(uniq), uniq[0:10])
    
# test question0
test_question(h_q0, huck)</code></pre><ol start="2"><li>You can use the <code>LessonUtil</code> autotester:</li></ol><pre><code>import LessonUtil as Util
h_tester = Util.HuckFinnAutoTester()
print(h_tester.test_question(h_q0, show_result_count=10))</code></pre><ol start="3"><li>You can use the official tester (which doesn't give you much control). It
tests all the questions.</li></ol><pre><code>ide.tester.test_functionality('huck')</code></pre><h3 id="hq1">h_q1:</h3><p class="new">How many total references are there to the days of the week (Monday, Tuesday, etc)?</p><p class="new">Hint: 18 (seems like stuff happens on Sunday) -- do not capture the plurals of each day.</p><div class="ide code-starter clearfix"><pre><code>def h_q1():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><p class="new"> </p><h3 id="hq2">h_q2:</h3><p class="new">How many female pronoun references are there (she, her, hers, herself, miss, mrs, ms)?</p><div class="ide code-starter clearfix"><pre><code>def h_q2():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><p class="new"> </p><h3 id="hq3-">h_q3: </h3><p class="new">How many male pronoun references are there (he, his, him, himself, mr)?</p><div class="ide code-starter clearfix"><pre><code>def h_q3():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><h3 id="hq4-">h_q4: </h3><p class="new">How many lines of complete dialog are there?  </p><p class="new">A line of complete dialog is defined as text that starts on its own line and 
the line starts with a quote (") and the ending quote (") ends a line.  </p><p class="new">A good example is shown on line 8518 and 8533 (you can easily get the lines of the
 text using a combination of <code>split</code> and array slicing).</p><img alt="lines8533.png" class="center" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/upy/reg_ex2/html/lines8533.png"/><p class="new">Note this does not capture all possible lines of dialog. For example, lines 1510, 
8296 and 8331 would not be captured by this definition.</p><p class="new">The first match should be line 130: </p><p class="new"><code>"Who dah?"</code></p><p class="new">2nd match: </p><p class="new"><code>"Say, who is you?  Whar is you?  Dog my cats ef I didn' hear sumf'n. Well, I know what I's gwyne to do:  I's gwyne to set down here and listen tell I hears it agin."</code></p><p class="new">Hint. </p><ul><li><code>h_q4</code> doesn't require a super long or complicated expression. It might be 
easiest to test on a small sample of text. Otherwise, it's very possible
that your code will hang because the regular expression is taking too 
long (e.g. too greedy) to execute.</li></ul><div class="ide code-starter clearfix"><pre><code>def h_q4():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><h2 id="10000-words">10000 Words</h2><p class="new">The following questions will use the words in 10000.txt. These are the 10,000 
most common/popular words in all the books in <a href="https://en.wiktionary.org/wiki/Wiktionary:Frequency_lists#Project_Gutenberg" target="_blank">Project Gutenberg</a></p><p class="new">For the patterns you write here, using greedy qualifiers (e.g. * ) <em>might</em> work 
since each word is on a single line. The same regular expression may not work 
in a body of text.  </p><h3 id="wq0--">w_q0:  </h3><p class="new">Find all the words that start and end with an 's' AND have at least one more 's' 
between the two. For example sisters</p><p class="new">Hint: 24</p><div class="ide code-starter clearfix"><pre><code>def w_q0():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><h4 id="testing">Testing</h4><p class="new">You can test these questions the same way as the first set:</p><pre><code>import LessonUtil as Util
w_tester = Util.WordAutoTester()
print(w_tester.test_question(w_q0, show_result_count=10))

# or use the autotester (which tests all the questions)
ide.tester.test_functionality('words')</code></pre><h3 id="wq1-">w_q1: </h3><p class="new">Using the '$' find all words that end in 'gry'.  </p><p class="new">Do not use word boundaries. What happens if you do (besides not passing the tests)?</p><div class="ide code-starter clearfix"><pre><code>def w_q1():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><h3 id="wq2-">w_q2: </h3><p class="new">How many 5 letter words are there in the 10,000 most common words?</p><div class="ide code-starter clearfix"><pre><code>def w_q2():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><p class="new"> </p><h3 id="wq3-">w_q3: </h3><p class="new">How many words have the word 'six' somewhere in them?</p><div class="ide code-starter clearfix"><pre><code>def w_q3():
  pattern = r''  
  return re.compile(pattern)</code></pre></div><h3 id="wq4--">w_q4:  </h3><p class="new">During your break, you are working on a crossword puzzle. You can't get the 
clue (TV ANTENNAS), but you have the following information: </p><p class="new"><code>üî≥ A üî≥Ô∏è B üî≥ T</code></p><p class="new">Find the possible words that work.</p><div class="ide code-starter clearfix"><pre><code>def w_q4():
  pattern = r'' 
  return re.compile(pattern)</code></pre></div><h1>Test and Submit</h1><p>Once you have finished, you can download your code (via <code>ide.tester</code>) and upload that file to Gradescope (find lesson with tag <strong>UP-RegEx2[wh][0-9]+</strong>).</p><div class="my-4"><pre><code><strong># to list the tests available</strong><br/>print(ide.tester.list_tests())<br/><strong># to perform a specific test</strong><br/>print(ide.tester.test_functionality('name of test'))<br/><strong># to test your code (either works)</strong><br/>print(ide.tester.test_notebook())<br/>print(ide.tester.test_notebook(verbose=True))<br/><strong># to prepare and download your code</strong><br/>ide.tester.download_solution()</code></pre></div><div class="lesson-footer flex bg-gray-200 justify-center"><div class="lesson-footer-card displaycard bg-blue-200 border-t border-gray-400 max-w-2xl rounded overflow-hidden shadow-lg"><div class="px-6 py-4"><div class="title-text text-center font-bold text-xl">Regular Expressions (part 2)</div><p class="text-center text-gray-800 text-xl">Finding patterns continued</p><div class="text-center mt-6 text-xl"><i aria-hidden="true" class="fas fa-tags"></i> any questions on Piazza with <span class="font-bold">UP-RegEx2[wh][0-9]+</span></div><div class="text-gray-700 text-base">¬†</div><div></div><div></div><div class="flex mt-4 border-t border-solid border-gray-500 justify-around bg-gray-200"><div class="text-gray-700 text-center px-4 m-2 text-sm">üêç¬†¬†4 D.S.</div><div class="text-gray-700 text-center px-4 m-2 text-sm"><strong>Version:</strong> <!-- -->SP21</div></div><div class="text-gray-700 mt-2 text-center text-sm font-bold">All Rights Reserved Michael Haberman</div><div class="text-gray-700 text-center text-sm">Do not distribute this notebook</div></div></div></div><div>¬†</div><div class="ide code-starter clearfix"><pre><code># print(ide.tester.test_notebook()) 
# print(ide.tester.test_notebook(verbose=True)) 

# once you are ready -- run this 
# ide.tester.download_solution() 
</code></pre></div></div></div></body></html>