<!DOCTYPE html><html lang='en'><head><title>Remote I/O</title><meta charset="utf-8"><style>/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}h1{font-size:2em;margin:.67em 0}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}strong{font-weight:bolder}code{font-family:monospace,monospace;font-size:1em}img{border-style:none}input{font-family:inherit;font-size:100%;line-height:1.15;margin:0}input{overflow:visible}[type=checkbox]{box-sizing:border-box;padding:0}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}h1,h2,h3,h4,p,pre{margin:0}ul{list-style:none;margin:0;padding:0}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e2e8f0}img{border-style:solid}input:-ms-input-placeholder{color:#a0aec0}input::-ms-input-placeholder{color:#a0aec0}input::-moz-placeholder{color:#a0aec0}h1,h2,h3,h4{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}input{padding:0;line-height:inherit;color:inherit}code,pre{font-family:Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}img{display:block;vertical-align:middle}img{max-width:100%;height:auto}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}.bg-gray-200{--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.bg-gray-300{--bg-opacity:1;background-color:#e2e8f0;background-color:rgba(226,232,240,var(--bg-opacity))}.bg-orange-300{--bg-opacity:1;background-color:#fbd38d;background-color:rgba(251,211,141,var(--bg-opacity))}.bg-green-200{--bg-opacity:1;background-color:#c6f6d5;background-color:rgba(198,246,213,var(--bg-opacity))}.bg-blue-200{--bg-opacity:1;background-color:#bee3f8;background-color:rgba(190,227,248,var(--bg-opacity))}.bg-blue-300{--bg-opacity:1;background-color:#90cdf4;background-color:rgba(144,205,244,var(--bg-opacity))}.border-gray-400{--border-opacity:1;border-color:#cbd5e0;border-color:rgba(203,213,224,var(--border-opacity))}.border-gray-500{--border-opacity:1;border-color:#a0aec0;border-color:rgba(160,174,192,var(--border-opacity))}.border-indigo-500{--border-opacity:1;border-color:#667eea;border-color:rgba(102,126,234,var(--border-opacity))}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.border-solid{border-style:solid}.border{border-width:1px}.border-l-2{border-left-width:2px}.border-t{border-top-width:1px}.cursor-pointer{cursor:pointer}.block{display:block}.inline-block{display:inline-block}.flex{display:flex}.justify-center{justify-content:center}.justify-around{justify-content:space-around}.float-left{float:left}.clearfix:after{content:"";display:table;clear:both}.clear-both{clear:both}.font-sans{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"}.font-serif{font-family:Georgia,Cambria,"Times New Roman",Times,serif}.font-semibold{font-weight:600}.font-bold{font-weight:700}.h-64{height:16rem}.text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-base{font-size:1rem}.text-xl{font-size:1.25rem}.leading-none{line-height:1}.leading-normal{line-height:1.5}.m-2{margin:.5rem}.my-4{margin-top:1rem;margin-bottom:1rem}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.mr-2{margin-right:.5rem}.mb-2{margin-bottom:.5rem}.mr-3{margin-right:.75rem}.mb-3{margin-bottom:.75rem}.mt-4{margin-top:1rem}.mb-4{margin-bottom:1rem}.mt-6{margin-top:1.5rem}.max-w-sm{max-width:24rem}.max-w-2xl{max-width:42rem}.object-contain{-o-object-fit:contain;object-fit:contain}.opacity-0{opacity:0}.overflow-hidden{overflow:hidden}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pl-3{padding-left:.75rem}.absolute{position:absolute}.shadow-md{box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06)}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}.shadow-inner{box-shadow:inset 0 2px 4px 0 rgba(0,0,0,.06)}.text-left{text-align:left}.text-center{text-align:center}.text-black{--text-opacity:1;color:#000;color:rgba(0,0,0,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-800{--text-opacity:1;color:#2d3748;color:rgba(45,55,72,var(--text-opacity))}.whitespace-no-wrap{white-space:nowrap}.w-1\/2{width:50%}.w-2\/3{width:66.666667%}.w-full{width:100%}@media (min-width:768px){.md\:w-2\/3{width:66.666667%}}.text-tiny{font-size:.5rem!important}body{color:#000!important;font-size:1.25rem!important}.main-content{max-width:900px}.lesson{padding-left:15px!important;padding-right:10px!important;--bg-opacity:1;background-color:#edf2f7;background-color:rgba(237,242,247,var(--bg-opacity))}.main-content,html{font-family:Arial,Georgia,Verdana,"Times New Roman"!important}.lesson-footer-card,.lesson-overview-card{font-family:"Times New Roman"!important}.lesson-footer{margin-top:50px;margin-top:20px}.lesson ul{list-style-position:inside;list-style-type:none;margin-left:1em}.lesson ul li{padding-left:1em;padding-right:5px}.lesson ul li::before{content:"•";padding-right:5px}span{white-space:nowrap}p.new{padding-top:0;padding-bottom:.5em}p.new+p{padding-top:.5em}h1,h2,h3,h4{font-weight:700;margin-top:.25em!important;margin-bottom:.05em!important;font-family:Georgia,Cambria,"Times New Roman",Times,serif!important}h1{font-size:2em!important;clear:both;color:#000!important}div+h1,h2{margin-top:0!important}h2{margin-top:.5em!important;font-size:1.5em!important;clear:both;color:#8b0000!important}h3{font-size:1.25em!important;clear:both;color:#006400!important}h4{font-size:1em!important;clear:both;color:#00008b!important}ul{margin-bottom:30px}p.new a{text-decoration:underline}.lesson a{text-decoration:underline;color:#00f}.title-text{font-size:2rem}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.5)}img.iw500{height:auto;width:auto;max-width:500px}code{font-size:smaller}pre code{font-size:15px}pre code:not(.line-number){background:#f4f4f4;font-family:monospace;font-size:15px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;touch-action:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;clear:both;border:1px solid #ddd;color:#666;page-break-inside:avoid;display:block;min-width:840px;max-width:840px;overflow:scroll;line-height:1.6;margin-bottom:1.6em;padding:1em 1.5em;-moz-tab-size:2;-o-tab-size:2;tab-size:2;word-wrap:break-word;white-space:pre-wrap;border-left:3px solid #f36d33}div.code-starter>pre code{border-left:3px solid #fdff44!important;background-image:radial-gradient(rgba(0,150,0,.75),#000 120%);color:#fff;font:.9rem Inconsolata,monospace}div.code-starter>pre code::after{content:"\a$_"}.tab{font-size:1rem;border-color:#8c6728}.tab-content{max-height:0;max-width:100%;transition:max-height .35s}.tab input:checked~.tab-content{max-height:100vh}.tab input:checked+label{padding:1rem;border-left-width:2px;border-color:#6574cd;background-color:#f8fafc;color:#6574cd}.tab label::after{float:right;right:0;top:0;display:block;width:1em;height:1.5em;line-height:1.5;font-size:1rem;text-align:center;transition:all .35s}.tab input[type=checkbox]+label::after{content:"+";font-weight:700;border-width:1px;border-radius:9999px;border-color:#8c6728}.tab input[type=checkbox]:checked+label::after{transform:rotate(315deg);background-color:#6574cd;color:#f8fafc}</style>
<script src="https://kit.fontawesome.com/7efc4bcee2.js" crossOrigin="anonymous"></script>
<script>
    let stateCheck = setInterval(function(){
      if (document.readyState === 'complete') {
        clearInterval(stateCheck);
        let s1 = document.getElementById('start');
        // console.log('doc is ready', s1);
        if (s1) {
           s1.setAttribute('tabindex', '-1');
           s1.focus(); 
           s1.scrollIntoView({behavior: 'smooth'}); 
           setTimeout(function(){s1.blur()}, 500);
           // console.log('focus set');
        }
      }
    }, 200);
    </script>
</head><body class="lesson"><div class="main-content lesson bg-gray-200 text-black p-1 pl-3 font-serif"><div class="md-inner">
<div id="start" class="section">&nbsp;</div><h1 class="overview"></h1><div class="lesson-overview bg-gray-200 flex justify-center"><div class="text-center px-4 py-2 m-2"><div class="lesson-overview-card displaycard bg-blue-200 max-w-sm rounded overflow-hidden shadow-lg"><div> </div><img alt="Text" class="object-contain h-64 w-full" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/upy/remote_io/html/upy-sm.png"/><div class="px-6 py-4"><div class="title-text text-center leading-none font-bold text-xl">Remote I/O</div><p class="text-center mt-2 text-gray-800 text-xl">using HTTP to get resources</p><div class="text-gray-700 text-base"> </div><div class="text-center mb-3"><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#info490</span><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#python</span><span class="inline-block bg-gray-300 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2">#remoteIO</span></div><div class="flex border-t border-solid border-gray-500 shadow-inner justify-around bg-blue-300"><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap">🐍  4 D.S.</span></div><div class="text-gray-700 text-center px-4 m-2 text-sm"><span class="whitespace-no-wrap"><strong>Version:</strong> <!-- -->SP21</span></div></div><div class="text-gray-700 mt-1 text-center text-tiny">All Rights Reserved</div></div></div></div><div class="text-center px-4 py-2 m-2 w-1/2"><div class="displaycard bg-gray-200 max-w-sm rounded overflow-hidden shadow-lg"><div class="px-6 py-4 text-left"><div class="text-center font-bold text-xl">Remote I/O<br/><div><span>prerequisites</span><div class="text-center text-xs mb-2">(start only after finishing)</div><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>bootcamp</strong></p><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>array slicing</strong></p><p class="max-w-sm text-gray-800 text-sm">⦿ <strong>local I/O</strong></p></div></div></div><div class="px-6 py-4 text-left text-gray-800"><div class="text-center font-bold text-xl">Colab Notes</div><p class="max-w-sm text-sm">1. <strong>Copy</strong> this notebook <img alt="copy2drive.png" class="inline-block" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/upy/remote_io/html/copy2drive.png"/></p><p class="max-w-sm text-sm">2. <strong>Update</strong> the <strong><code>NET_ID</code></strong> in the notebook</p><p class="max-w-sm text-gray-800 text-sm">3. <strong>Hit ▶️ </strong> to install the INFO 490 IDE</p><div class="text-center font-bold text-xl"> </div><div class="text-center font-bold text-xl">Jupyter/PyCharm Notes</div><p class="max-w-sm text-gray-800 text-sm text-left">The testing framework does <strong>not work</strong> (at this time) for Jupyter  notebooks or local code development.</p></div></div></div></div><h1 class="section" id="section1">Remote I/O</h1><h2 id="using-http-to-get-resources">using HTTP to get resources</h2><p class="new">In a previous lesson we learned about getting data from a 'local' resource -- 
specifically a file resource.  We are going to build upon that knowledge to 
learn how to access resources on the Internet. As you will see, the steps 
of opening a resource, reading the resource, and then closing it are still
 present. However, we will be using different Python APIs (application 
 programming interfaces) for working with different libraries to access 
 remote resources. </p><h3 id="too-much-terminology-">Too much terminology </h3><p class="new">This lesson is packed with potentially new words, concepts, and acronyms. Read slowly. 
If you don't understand something, reach out and ask questions -- we will be 
happy to clarify. Let's go over some of the terminology for accessing remote content.</p><h2 id="protocols">Protocols</h2><p class="new">Almost all the resources we will access will be available via <strong>HTTP</strong> (HyperText 
Transfer Protocol) and HTTP<strong>S</strong> (Secure) <em>protocol</em>. A <strong>protocol</strong> is simply a set of rules 
that each participant in the data exchange must adhere to for communication to happen. 
These protocols are built on top of other well established 'Internet' protocols 
such as <strong>TCP</strong> (Transfer Control Protocol -- which helps in reliable data delivery) 
and <strong>IP</strong> (Internet Protocol -- which helps in routing data from one machine to another) 
that utilize an engineering technique called <strong>layering</strong> (much like the data 
science pipeline) -- where each protocol (or step in the pipeline) can use the 
protocol it's building upon (or the previous step in the pipeline).  </p><h2 id="web-services">Web Services</h2><p class="new">Almost any resource that is accessible via HTTP/S has a web server listening to 
a specific <strong>port</strong> on a machine.  A port (80 for HTTP and 443 for HTTPS) is just a 
mechanism for the operating system to know how to hand off incoming network 
data to the correct process.  A closely related idea is that of a <strong>web service</strong>. 
A web service uses the same technologies of a web server, however, the requester 
for data to a web service is typically another computer (not a person, but a program). </p><p class="new">You may have heard of <strong>REST</strong> (Representational State Transfer) 
and <strong>SOAP</strong> (Simple Object Access Protocol) that further define rules on 
how to access resources using HTTP (SOAP uses <em>SMTP</em>). Both of these are 
typical protocols used by web services -- they need to tightly define the 
rules for locating a resource and for the <strong>encoding</strong> (rules to package the data) the
 data to send.</p><h2 id="words-that-connect">Words that Connect</h2><img alt="ds1.jpg" class="float-left mr-3 iw500" src="https://raw.githubusercontent.com/habermanUIUC/CodeStoryLessons/main/lessons/p4ds/upy/remote_io/html/ds1.jpg"/><p class="new">For every request you make (using HTTP, for example) to a server there's some 
basic terminology that needs to be memorized.  </p><div class="clear-both text-sm mb-4">image <a href="https://hackernoon.com/http-made-easy-understanding-the-web-client-server-communication-yz783vg3" target="_blank">source</a></div><p class="new">The <strong>client</strong> is the host that is making the request for some resource. For
 example, in most web requests, the browser is the client.  When we write
  python code to download a book, our code is the client.</p><p class="new">The <strong>server</strong> (the thing that manages the resource) handles the request and returns a
 response. So for every connection, there is a client, a server, a request and a response. 
 The client and server can be the same physical machine as well.</p><h2 id="request-types">Request Types</h2><p class="new">if a resource can be accessed via a URL (in the browser address bar) the
 request is called a <strong>GET request</strong> (<strong>POST request</strong>s puts the data in the 
 request message or body and not in the URL). We will focus most of our 
 attention on simple HTTP GET requests. There are other types of HTTP requests (e.g. POST, PUT, DELETE).</p><h2 id="the-url">The URL</h2><p class="new">Of course the most important part of a remote request will be the 
<strong>URL</strong> (Uniform Resource Locator). The URL is a string that identifies a resource 
and how to access it. It is made up of several components. Knowing these 
components will help you navigate Python documentation that describes how to 
manipulate different parts of the URL and/or the connection.</p><h3 id="url-by-example">URL by Example</h3><p class="new">Let's look at a simple URL:</p><pre><code>http://www.gutenberg.org/files/76/76-0.txt</code></pre><p class="new">and look at how it can be broken down into different components.</p><h4 id="the-scheme">The Scheme</h4><ul><li><strong><code>http</code></strong><code>://www.gutenberg.org/files/76/76-0.txt</code></li></ul><p class="new">The scheme identifies what communication protocol (HTTP or HTTPS) will be used 
to access the resource. It is usually HTTP or HTTPS, but can also be 
something like FTP (File Transfer Protocol -- an old protocol for getting files) as well.</p><h4 id="the-hostport--">The Host:Port  </h4><p class="new">The next item is the hostname followed by a port number. If the port number 
is not specified, the default port is used.  Hostnames can be specified via <strong>DNS</strong> 
names (Domain Name Service) or IP addresses: </p><ul><li><code>http://</code><strong><code>www.gutenberg.org</code></strong><code>/files/76/76-0.txt</code></li><li><code>http://</code><strong><code>www.gutenberg.org:80</code></strong><code>/files/76/76-0.txt</code></li><li><code>http://</code><strong><code>173.194.219.113:80</code></strong></li></ul><p class="new">Typically, we use DNS names for identifying the server.</p><h4 id="the-path">The Path</h4><p class="new">The <strong>path</strong> identifies the specific resource the client (e.g. the web browser) 
wants to access on the server:</p><ul><li><code>http://www.gutenberg.org/</code><strong><code>files/76/76-0.txt</code></strong></li></ul><p class="new">In this case the path is a specific file, but a resource could be a script
 (like <strong>php</strong> -- another coding language) or a program that gets run
 /executed on the server and whose <em>output</em> is the response (e.g. an SQL or database query).</p><h4 id="the-query-string">The Query String</h4><p class="new">The query string is optional but it allows you to pass additional information 
to the web server to access different aspects of the resource. For example, 
the following URL contains the query parameters:</p><ul><li><code>https://en.wikipedia.org/w/api.php?</code><strong><code>action=parse&amp;format=json&amp;page=Steve+Jobs&amp;prop=text</code></strong></li></ul><p class="new">The parameters are <code>action</code>, <code>format</code>, <code>page</code>, <code>prop</code>.  In this case we are 
retrieving data from a web service (the output isn't meant for our visual consumption). 
The query field starts with a <code>?</code> and each key/value pair is separated with the <code>&amp;</code> symbol.</p><h2 id="url-encoding">URL <strong>encoding</strong></h2><p class="new">You may have noticed that the URL used to request a resource cannot contain a space.<br/>There are other characters that are also not allowed as well. You can see the 
original <a href="https://tools.ietf.org/html/rfc3986#section-2" target="_blank">specification</a>. The 
Request for Comments (RFC) document(s) have been used by the Internet community 
to define new standards and share technical information.</p><p class="new">For query values that have special characters or spaces, you will need to 
<em>encode</em> them. URL encoding involves translating unprintable characters or characters 
with special meaning within URLs to a representation that is unambiguous and universally 
accepted by web browsers and servers. In the above query to Wikipedia, notice 
that for the <code>page</code> parameter, the space is replaced with a <code>+</code> character. 
You can also use the <code>%20</code> character(s) to encode the space: </p><ul><li><code>https://www.google.com/search?as_q=apollo</code><strong><code>%20</code></strong><code>13</code></li></ul><p class="new">Almost all browsers will encode the URL for you when you type it in the 
address bar of the browser; however, the Python libraries <strong>will not</strong>. You will 
have to encode them yourself or with the provided functions. </p><h2 id="header-fields">Header Fields</h2><p class="new">You can set and read different aspects of the HTTP request and response that 
define the details of the communication between the client and the server. HTTP 
headers define the operating parameters for the process of data transfer from 
source to destination. </p><p class="new">They can also provide information <em>about</em> the source and destination, determine the 
data transmission mode and encoding type. Headers also specify information about the content, 
its type and size, and can be used to restrict the amount and variety of data 
allowed at both ends of the communication. To ensure security, values in the header 
can specify the time for which data will be valid, mandate that each side of 
the communication proves their legitimacy and identity, keep unwanted readers 
 from reading, and ensure data integrity with the help of hash values.</p><p class="new">Headers can also provide information about the client, server, and the application 
handling the HTTP communication environment. Things like <strong>cookies</strong> (information 
 saved on the client), <strong>cache control</strong> (using 'old' information), <strong>authorization</strong> 
 (who is allowed), etc are normally handled by setting the correct header fields 
 in a request.  Although we won't be setting or reading the headers, 
 you should know that capability exists.</p><h2 id="status-types">Status Types</h2><p class="new">When you make a request to a web server (or web service), not only do you 
get a response, but you also get <strong>metadata</strong> (data about the data) regarding 
the response. The most important is that of the <strong>status code</strong>.  A status
 code is a numeric value the server sends to the client (you may have seen a
  404 status code before -- which means the resource requested does not exist).</p><p class="new">A status code of <code>200</code>, means the request was completed without any errors. When 
the status code is not OK (i.e. not <code>200</code>), you should at least log the error 
and determine how to handle the response.  We have all seen <code>404</code> responses 
before (resource not found) when a resource has been moved or removed from a server.</p><h1 class="section" id="section2">Python Remote I/O</h1><p class="new">With all that background, we can start using Python to get access to remote 
resources. There are two well supported libraries to access remote resources
 with Python.  There are many other libraries as well, but the two shown here
  come with every Python distribution.</p><h2 id="the-urllib-module">the <code>urllib</code> module</h2><p class="new">One of the earliest Python modules for accessing remote content is <code>urllib</code>. 
It's a module that is available with all Python distributions. If you can't 
update/change/add Python libraries, this is the most 'raw' way to get a remote resource. </p><pre><code>import urllib.request
def simple_remote_fetch(url):
  rd = urllib.request.urlopen(url)
  data = rd.read()
  rd.close()
  return str(data)</code></pre><p class="new">There are a few issues with that function, but for now we will focus on the 
main components.  Much like local I/O file handling, we open, read, and close 
the resource.  We are assuming the data can be converted to a string so we 
return the converted data (this is an assumption that is not always true).</p><p class="new">Now we can test it by fetching <em>Emma</em> By Jane Austen from Project Gutenberg:</p><div class="ide code-starter clearfix"><pre><code>def fetch_demo():
    emma = "https://www.gutenberg.org/files/158/158-0.txt"
    text = simple_remote_fetch(emma)
    idx = text.find(r"EMMA\r\n")
    print(text[idx:idx+106])</code></pre></div><ul><li>The <code>r</code> in front of the string <code>"Emma"</code> tells Python not to change the 
literal control characters found in the string (the <code>\r \n</code> are characters that 
display a new line).  Both of these will be explored further (and explained better) 
in the lesson on regular expressions.</li><li>The <code>106</code> constant was chosen so enough of the text could be displayed -- it
was chosen only for demonstration purposes.</li></ul><h1 class="section" id="section3">A Better Version</h1><p class="new">Take a look at the following code.  The function <code>read_remote</code> shows
 how to open a connection and read the incoming data. It also uses the <code>with</code> 
 statement so that any resources used are released properly -- even under error 
 conditions. In general, when you write local or remote I/O functions, you 
 need to cover all the possible cases where the wrong thing happens.  </p><p class="new">The example also shows how to handle different error conditions. Normally, you 
would not print an error condition but rather raise an exception with a clear 
message (unlike some of the messages that come from the testing framework).</p><p class="new">When you read a remote resource over the Internet, many things can go wrong. 
The status code also gives some information when the resource requested could not 
be located. The Python <a href="https://docs.python.org/3/library/http.html" target="_blank">documentation on http</a>
provides a list of possible error conditions.  Be sure to test the following
 code by fetching <code>emma</code> from Project Gutenberg.</p><div class="ide code-starter clearfix"><pre><code>import urllib.request
def read_remote(url):
  try:
    with urllib.request.urlopen(url) as response:
      #status = response.getcode()
      #should check the status == 200 
      data = response.read()
      output = data.decode('utf-8')
      return output
  except urllib.error.HTTPError as e:
    # Return code error (e.g. 404, 501, ...)
    # ...
    print('HTTPError: {}'.format(e.code))
    return None
  except urllib.error.URLError as e:
    # Not an HTTP-specific error (e.g. connection refused)
    print('URLError: {}'.format(e.reason))
    return None</code></pre></div><h2 id="encoding-requests">Encoding Requests</h2><p class="new">You can use the <code>urlencode</code> function to ensure your URLs and query parameters 
are properly encoded -- that is those characters that are not allowed can 
easily be handled.  The example provides an <code>encode</code> function that simply 
wraps the urllib's function. It allows you to take a set of name/value pairs 
and properly encode them.  Here's a quick example:</p><div class="ide code-starter clearfix"><pre><code>import urllib.parse

def encode(dictionary):
  return urllib.parse.urlencode(dictionary)

map = {'artist': 'Bo Diddley',
       'song'  : 'Who Do You Love?'}
print(encode(map))</code></pre></div><p class="new">In general the full url can be created using the following pattern:</p><pre><code>def build_url(base_url, params):
  url = baseurl + "?" + urllib.parse.urlencode(params) 
  return url</code></pre><p class="new">A newer library, <code>urllb2</code>, provides additional functionality over <code>urllib</code> but 
is not available for older versions of Python. And if you are using a newer 
version of Python (e.g. 3.x), there are better libraries that build 
functionality on top of <code>urllib</code>.</p><h2 id="the-requests-module">The <code>requests</code> module</h2><p class="new">One of the more popular ways to request remote resources is with the <code>requests</code> 
module.  The following code implements the same <code>read_remote</code> function but 
uses the <code>requests</code> module.  This example also shows how to check the 
status code of the response.</p><div class="ide code-starter clearfix"><pre><code>import requests
# see http://docs.python-requests.org/en/master/

def read_remote(url):
  # assumes the url is already encoded (see urllib.parse.urlencode)
  with requests.get(url) as response:
    response.encoding = 'utf-8'
    return response.text
  return None

def read_remote_with_params(url, params): 
  # assumes the url is already encoded (see urllib.parse.urlencode)
  response = requests.get(url, params)
  if response.status_code == requests.codes.ok: # that is 200
    response.encoding = 'utf-8'
    return response.text
  return None</code></pre></div><p class="new">Be sure to test the new <code>read_remote</code> function.</p><p class="new">For the most part, we are going to keep the functionality of reading a resource 
very simple -- it will almost never do more than what we have done in the two 
examples.  Data processing that needs to happen and is specific to 
remote data (rather than local data) would be one possible exception.</p><div class="font-sans container mt-1 mb-4 "><p>🎗Before you go, you should <strong>know</strong>:</p><div class="w-2/3 md:w-2/3"><div class="shadow-md"><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-35" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-35"><span> what a url is </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-36" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-36"><span> what a query string is </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-37" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-37"><span> what's a network protocol </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-38" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-38"><span> what's the difference between https and http </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div><div class="tab overflow-hidden border-t bg-green-200"><input class="absolute opacity-0" id="tab-multi-39" name="tabs" type="checkbox"/><label class="block p-3 leading-normal cursor-pointer" for="tab-multi-39"><span> how to download a remote resource using Python </span></label><div class="tab-content overflow-hidden border-l-2 bg-orange-300 border-indigo-500 leading-normal"><p class="p-3">No Answer</p></div></div></div></div></div><h1 class="section" id="section4">Lesson Assignment</h1><h2 id="2-be-or-">2 Be or !¹</h2><h2 id="step-1-">Step 1. </h2><p class="new">Find the text for Hamlet by William Shakespeare at Project Gutenberg EBook. 
Since we will be parsing the contents, be sure the url is for the raw text 
version of the play.</p><ul><li>use the most downloaded text version (ebook #1524)</li><li>create the function <code>get_hamlet_url</code> which returns the url (a string) for this play.</li></ul><div class="ide code-starter clearfix"><pre><code></code></pre></div><h2 id="step-2">Step 2:</h2><p class="new">Create the function <code>get_remote_text(url)</code> that fetches the remote data 
using the url passed in.  You can decide which library you want to use. Wrap 
your entire function with a <code>try/except</code> construct.  If any error happens, 
return <code>None</code> otherwise return the result as a string.</p><p class="new">Notes:</p><ul><li>Hamlet is encoded in UTF-8 (unicode).  We will learn more about that soon, 
but for now if you decide to use the <code>urllib.request</code> library you need to decode the data using the following:</li></ul><pre><code>    data   = rd.read()
    output = data.decode('utf-8')</code></pre><p class="new">If you use the <code>requests</code> library, it does this automatically for you in 
most cases. Adding <code>response.encoding = 'utf-8'</code> does the same thing.</p><div class="ide code-starter clearfix"><pre><code></code></pre></div><h2 id="step-3">Step 3:</h2><p class="new">Create a function named <code>extract_passage</code> that has a single parameter (the 
text from step 2) and extracts the famous passage from Hamlet (i.e. to be or not to be) 
using the following restrictions:</p><ul><li>You cannot use any hardcoded numbers (e.g. 1526). You should use the power
of methods on the string type to find these indices (revisit the lesson on Strings or the Python documentation)</li><li>Use Python's slice notation (e.g. <code>return passage[start:end]</code> )</li><li>Extract the entire passage.  The passage starts with <strong>To</strong> and ends with a period <strong><code>.</code></strong> (just before OPHELIA speaks).</li><li>You should remove any leading or trailing white space</li><li>If you can't seem to fetch the contents of Hamlet, first try getting it via 
the browser.  Make sure to test your code locally before running the tests as well.</li></ul><div class="ide code-starter clearfix"><pre><code></code></pre></div><h1>Test and Submit</h1><p>Once you have finished, you can download your code (via <code>ide.tester</code>) and upload that file to Gradescope (find lesson with tag <strong>UP-RemoteIO</strong>).</p><div class="my-4"><pre><code><strong># to list the tests available</strong><br/>print(ide.tester.list_tests())<br/><strong># to perform a specific test</strong><br/>print(ide.tester.test_functionality('name of test'))<br/><strong># to test your code (either works)</strong><br/>print(ide.tester.test_notebook())<br/>print(ide.tester.test_notebook(verbose=True))<br/><strong># to prepare and download your code</strong><br/>ide.tester.download_solution()</code></pre></div><div class="lesson-footer flex bg-gray-200 justify-center"><div class="lesson-footer-card displaycard bg-blue-200 border-t border-gray-400 max-w-2xl rounded overflow-hidden shadow-lg"><div class="px-6 py-4"><div class="title-text text-center font-bold text-xl">Remote I/O</div><p class="text-center text-gray-800 text-xl">using HTTP to get resources</p><div class="text-center mt-6 text-xl"><i aria-hidden="true" class="fas fa-tags"></i> any questions on Piazza with <span class="font-bold">UP-RemoteIO</span></div><div class="text-gray-700 text-base"> </div><div></div><div class="text-gray-700 text-base">References and Additional Readings</div><div class="text-xs p-2 border border-solid border-gray-500 bg-gray-300"> <div class="text-gray-700 px-4 m-2">• <!-- --> <a href="https://docs.python.org/3.6/library/http.html#http-status-codes" target="_blank">https://docs.python.org/3.6/library/http.html#http-status-codes</a></div></div><div class="flex mt-4 border-t border-solid border-gray-500 justify-around bg-gray-200"><div class="text-gray-700 text-center px-4 m-2 text-sm">🐍  4 D.S.</div><div class="text-gray-700 text-center px-4 m-2 text-sm"><strong>Version:</strong> <!-- -->SP21</div></div><div class="text-gray-700 mt-2 text-center text-sm font-bold">All Rights Reserved Michael Haberman</div><div class="text-gray-700 text-center text-sm">Do not distribute this notebook</div></div></div></div><div> </div><div class="ide code-starter clearfix"><pre><code># print(ide.tester.test_notebook()) 
# print(ide.tester.test_notebook(verbose=True)) 

# once you are ready -- run this 
# ide.tester.download_solution() 
</code></pre></div><ul><li>¹ The <code>!</code> sign is commonly used to represent the boolean NOT operator in many programming 
languages (except Python). So it may or may not be a visual pun.</li></ul></div></div></body></html>